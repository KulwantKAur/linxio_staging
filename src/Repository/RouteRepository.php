<?php

namespace App\Repository;

use App\Command\Tracker\UpdateWrongRoutesCommand;
use App\Entity\Area;
use App\Entity\AreaGroup;
use App\Entity\Depot;
use App\Entity\Device;
use App\Entity\DrivingBehavior;
use App\Entity\Route;
use App\Entity\RouteFinishArea;
use App\Entity\RouteStartArea;
use App\Entity\RouteTemp;
use App\Entity\Speeding;
use App\Entity\Tracker\TrackerHistory;
use App\Entity\User;
use App\Entity\UserGroup;
use App\Entity\Vehicle;
use App\Entity\VehicleGroup;
use App\Entity\VehicleOdometer;
use App\Report\Core\DTO\FbtDriverReportDTO;
use App\Report\Core\DTO\FbtVehicleReportDTO;
use App\Report\Core\DTO\FbtReportDTO;
use App\Report\Core\DTO\RouteReportDTO;
use App\Report\Core\DTO\StopReportDTO;
use App\Repository\Traits\FiltersTrait;
use App\Util\DateHelper;
use App\Util\StringHelper;
use Carbon\Carbon;
use Doctrine\Common\Collections\Criteria;
use Doctrine\DBAL\ArrayParameterType;
use Doctrine\DBAL\Connection;
use Doctrine\DBAL\Types\Types;
use Doctrine\ORM\Query;
use Doctrine\ORM\Query\Expr\Orx;

/**
 * RouteRepository
 *
 * This class was generated by the Doctrine ORM. Add your own custom
 * repository methods below.
 */
class RouteRepository extends \Doctrine\ORM\EntityRepository
{
    use FiltersTrait;

    /**
     * @param Device $device
     * @param $dateFrom
     * @param $dateTo
     * @return array|null
     */
    public function getRoutesByDevice(Device $device, $dateFrom, $dateTo): ?array
    {
        return $this->getEntityManager()
            ->createQueryBuilder()
            ->select('r')
            ->from(Route::class, 'r')
            ->leftJoin('r.device', 'd')
            ->andWhere('(r.startedAt BETWEEN :dateFrom AND :dateTo) OR (r.finishedAt BETWEEN :dateFrom AND :dateTo)')
            ->orWhere('r.startedAt < :dateFrom AND r.finishedAt > :dateTo')
            ->andWhere('d.id = :deviceId')
            ->setParameter('deviceId', $device->getId())
            ->setParameter('dateFrom', $dateFrom)
            ->setParameter('dateTo', $dateTo)
            ->orderBy('r.startedAt', Criteria::ASC)
            ->getQuery()
            ->getResult();
    }

    public function getRoutesByVehicle(
        Vehicle $vehicle,
        $dateFrom,
        $dateTo,
        $limit = null,
        $offset = null,
        $selectCount = false,
        $order = Criteria::ASC
    ) {
        $qb = $this->getEntityManager()->createQueryBuilder();
        if ($selectCount) {
            $qb->select('count(r) as count');
        } else {
            $qb->select('r')
                ->orderBy('r.startedAt', $order);
        }

        $qb->from(Route::class, 'r')
            ->where('r.vehicle = :vehicle')
            ->andWhere(
                $qb->expr()->andX(
                    $qb->expr()->lt('r.startedAt', ':dateTo'),
                    $qb->expr()->gt('r.finishedAt', ':dateFrom')
                )
            )
            ->setParameter('vehicle', $vehicle)
            ->setParameter('dateFrom', $dateFrom)
            ->setParameter('dateTo', $dateTo);

        if ($limit) {
            $qb->setMaxResults($limit);
        }

        if ($offset) {
            $qb->setFirstResult($offset);
        }

        if ($selectCount) {
            return $qb->getQuery()->getSingleResult()['count'];
        } else {
            return $qb->getQuery()->getResult();
        }
    }

    public function getRoutesByDriverForUnassign(
        User $driver,
        Vehicle $vehicle,
        $dateFrom,
        $dateTo,
        $limit = null,
        $offset = null,
        $selectCount = false,
        $order = Criteria::ASC
    ) {
        $qb = $this->getEntityManager()->createQueryBuilder();
        if ($selectCount) {
            $qb->select('count(r) as count');
        } else {
            $qb->select('r')
                ->orderBy('r.startedAt', $order);
        }

        $qb->from(Route::class, 'r')
            ->andWhere('r.driver = :driver')
            ->andWhere('r.vehicle <> :vehicle')
            ->andWhere(
                $qb->expr()->andX(
                    $qb->expr()->lt('r.startedAt', ':dateTo'),
                    $qb->expr()->gt('r.finishedAt', ':dateFrom')
                )
            )
            ->setParameter('driver', $driver)
            ->setParameter('vehicle', $vehicle)
            ->setParameter('dateFrom', $dateFrom)
            ->setParameter('dateTo', $dateTo);

        if ($limit) {
            $qb->setMaxResults($limit);
        }

        if ($offset) {
            $qb->setFirstResult($offset);
        }

        if ($selectCount) {
            return $qb->getQuery()->getSingleResult()['count'];
        } else {
            return $qb->getQuery()->getResult();
        }
    }

    public function getByDevice(
        Device $device,
        $dateFrom,
        $dateTo,
        $limit = null,
        $offset = null,
        $selectCount = false,
        $order = Criteria::ASC
    ) {
        $qb = $this->getEntityManager()->createQueryBuilder();
        if ($selectCount) {
            $qb->select('count(r) as count');
        } else {
            $qb->select('r')
                ->orderBy('r.startedAt', $order);
        }

        $qb->from(Route::class, 'r')
            ->where('r.device = :device')
            ->andWhere(
                $qb->expr()->orX(
                    $qb->expr()->andX(
                        $qb->expr()->lt('r.startedAt', ':dateTo'),
                        $qb->expr()->gte('r.finishedAt', ':dateFrom')
                    ),
                    $qb->expr()->andX(
                        $qb->expr()->lt('r.startedAt', ':dateTo'),
                        $qb->expr()->isNull('r.finishedAt')
                    )
                )
            )
            ->setParameter('device', $device)
            ->setParameter('dateFrom', $dateFrom)
            ->setParameter('dateTo', $dateTo);

        if ($limit) {
            $qb->setMaxResults($limit);
        }

        if ($offset) {
            $qb->setFirstResult($offset);
        }

        if ($selectCount) {
            return $qb->getQuery()->getSingleResult()['count'];
        } else {
            return $qb->getQuery()->getResult();
        }
    }

    /**
     * @param User $driver
     * @param $dateFrom
     * @param $dateTo
     * @param User $currentUser
     * @return array|null
     */
    public function getRoutesByDriver(User $driver, $dateFrom, $dateTo, User $currentUser): ?array
    {
        $qb = $this->getEntityManager()->createQueryBuilder();

        $qb = $qb->select('r')
            ->from(Route::class, 'r')
            ->where('r.driver = :driver')
            ->andWhere(
                $qb->expr()->andX(
                    $qb->expr()->lte('r.startedAt', ':dateTo'),
                    $qb->expr()->gte('r.finishedAt', ':dateFrom')
                )
            )
            ->setParameter('driver', $driver)
            ->setParameter('dateFrom', $dateFrom)
            ->setParameter('dateTo', $dateTo)
            ->orderBy('r.startedAt', Criteria::ASC);

        if ($currentUser->needToCheckUserGroup()) {
            $userVehicles = $this->getEntityManager()->getRepository(UserGroup::class)
                ->getUserVehiclesIdFromUserGroup($currentUser);
            $qb->andWhere('IDENTITY(r.vehicle) in (:vehicleIds)')->setParameter('vehicleIds', $userVehicles);
        }

        return $qb->getQuery()->getResult();
    }

    /**
     * @param int|null $driverId
     * @param int|null $vehicleId
     * @param $dateFrom
     * @param $dateTo
     * @param $vehicleIds
     * @param string|null $scope
     * @return array|null
     */
    public function getRoutesByDriverOrVehicle(
        ?int $driverId,
        ?int $vehicleId,
        $dateFrom,
        $dateTo,
        $vehicleIds,
        ?string $scope
    ): ?array {
        $query = $this->getEntityManager()
            ->createQueryBuilder()
            ->select('r')
            ->from(Route::class, 'r')
            ->setParameter('dateFrom', $dateFrom)
            ->setParameter('dateTo', $dateTo)
            ->andWhere('IDENTITY(r.vehicle) IN (:vehicleIds)')
            ->setParameter('vehicleIds', $vehicleIds)
            ->orderBy('r.startedAt', Criteria::ASC);

        $query->andWhere(
            $query->expr()->andX(
                $query->expr()->lte('r.startedAt', ':dateTo'),
                $query->expr()->gte('r.finishedAt', ':dateFrom')
            )
        );

        if ($driverId) {
            $query->andWhere('IDENTITY(r.driver) = :driverId')
                ->setParameter('driverId', $driverId);
        }

        if ($vehicleId) {
            $query->andWhere('IDENTITY(r.vehicle) = :vehicleId')
                ->setParameter('vehicleId', $vehicleId);
        }

        if ($scope) {
            $query->andWhere('r.scope = :scope')
                ->setParameter('scope', $scope);
        }

        return $query->getQuery()->getResult();
    }

    /**
     * @param int|null $driverId
     * @param int|null $vehicleId
     * @param $dateFrom
     * @param $dateTo
     * @param User $currentUser
     * @return array|null
     */
    public function getRoutesByDriverOrVehicleAndDateRange(
        ?int $driverId,
        ?int $vehicleId,
        $dateFrom,
        $dateTo,
        ?User $currentUser = null
    ): ?array {
        $query = $this->getEntityManager()
            ->createQueryBuilder()
            ->select('r')
            ->from(Route::class, 'r')
            ->where('r.type = :type')
            ->setParameter('dateFrom', $dateFrom)
            ->setParameter('dateTo', $dateTo)
            ->setParameter('type', Route::TYPE_DRIVING)
            ->orderBy('r.startedAt', Criteria::ASC);

        $query->andWhere(
            $query->expr()->andX(
                $query->expr()->lte('r.startedAt', ':dateTo'),
                $query->expr()->gte('r.finishedAt', ':dateFrom')
            )
        );

        if ($driverId) {
            $query->andWhere('IDENTITY(r.driver) = :driverId')
                ->setParameter('driverId', $driverId);
        }

        if ($vehicleId) {
            $query->andWhere('IDENTITY(r.vehicle) = :vehicleId')
                ->setParameter('vehicleId', $vehicleId);
        }

        if ($currentUser && $currentUser->needToCheckUserGroup()) {
            $userVehicles = $this->getEntityManager()->getRepository(UserGroup::class)
                ->getUserVehiclesIdFromUserGroup($currentUser);
            $query->andWhere('IDENTITY(r.vehicle) in (:vehicleIds)')->setParameter('vehicleIds', $userVehicles);
        }

        return $query->getQuery()->getResult();
    }

    /**
     * @param Route $route
     * @return Route|null
     * @throws \Doctrine\ORM\NonUniqueResultException
     */
    public function getPreviousRoute(Route $route): ?Route
    {
        $qb = $this->getEntityManager()
            ->createQueryBuilder()
            ->select('r')
            ->from(Route::class, 'r')
            ->andWhere('r.finishedAt = :startDate')
            ->andWhere('r.device = :device')
            ->setParameter('startDate', $route->getStartedAt())
            ->setParameter('device', $route->getDevice());

        return $qb->getQuery()
            ->setMaxResults(1)
            ->getOneOrNullResult();
    }

    /**
     * @param Route $route
     * @return Route|null
     * @throws \Doctrine\ORM\NonUniqueResultException
     */
    public function getPreviousRouteWithOdometer(Route $route): ?Route
    {
        $qb = $this->getEntityManager()->createQueryBuilder();
        $query = $qb
            ->select('r')
            ->from(Route::class, 'r')
            ->andWhere('r.id < :routeId')
            ->andWhere('r.device = :device')
            ->andWhere('r.vehicle = :vehicle')
            ->andWhere($qb->expr()->orX(
                $qb->expr()->isNotNull('r.startOdometer'),
                $qb->expr()->isNotNull('r.finishOdometer')
            ))
            ->setParameter('routeId', $route->getId())
            ->setParameter('device', $route->getDevice())
            ->setParameter('vehicle', $route->getVehicle());
        $prevRoute = $query->getQuery()->setMaxResults(1)->getOneOrNullResult();

        return ($prevRoute && $prevRoute->getStartedAt() < $route->getStartedAt()) ? $prevRoute : null;
    }

    /**
     * @param int $deviceId
     * @param string $date
     * @return Route|null
     * @throws \Doctrine\ORM\NonUniqueResultException
     */
    public function getPreviousStopRoute(int $deviceId, string $date): ?Route
    {
        $qb = $this->getEntityManager()
            ->createQueryBuilder()
            ->select('r')
            ->from(Route::class, 'r')
            ->andWhere('r.finishedAt = :startDate')
            ->andWhere('IDENTITY(r.device) = :deviceId')
            ->andWhere('r.type = :type')
            ->setParameter('startDate', $date)
            ->setParameter('deviceId', $deviceId)
            ->setParameter('type', Route::TYPE_STOP);

        return $qb->getQuery()
            ->setMaxResults(1)
            ->getOneOrNullResult();
    }

    /**
     * @param Route $route
     * @return Route|null
     * @throws \Doctrine\ORM\NonUniqueResultException
     */
    public function getNextRoute(Route $route): ?Route
    {
        return $this->getEntityManager()
            ->createQueryBuilder()
            ->select('r')
            ->from(Route::class, 'r')
            ->where('r.pointStart = :finishPoint')
            ->andWhere('r.device = :device')
            ->setParameter('finishPoint', $route->getPointFinish())
            ->setParameter('device', $route->getDevice())
            ->getQuery()
            ->setMaxResults(1)
            ->getOneOrNullResult();
    }

    /**
     * @param Route $route
     * @return Route|null
     * @throws \Doctrine\ORM\NonUniqueResultException
     */
    public function getNextRouteByClosestTime(Route $route): ?Route
    {
        return $this->getEntityManager()
            ->createQueryBuilder()
            ->select('r')
            ->from(Route::class, 'r')
            ->where('r.startedAt > :date')
            ->andWhere('r.device = :device')
            ->setParameter('date', $route->getStartedAt())
            ->setParameter('device', $route->getDevice())
            ->orderBy('r.startedAt', Criteria::ASC)
            ->getQuery()
            ->setMaxResults(1)
            ->getOneOrNullResult();
    }

    /**
     * @param Device $device
     * @param \DateTimeInterface $dateFrom
     * @param \DateTimeInterface $dateTo
     * @return Route|null
     * @throws \Doctrine\ORM\NonUniqueResultException
     */
    public function getClosestPrevRouteByDeviceAndDate(
        Device $device,
        \DateTimeInterface $dateFrom,
        \DateTimeInterface $dateTo
    ): ?Route {
        return $this->getEntityManager()
            ->createQueryBuilder()
            ->select('r')
            ->from(Route::class, 'r')
            ->where('r.startedAt <= :dateFrom')
            ->andWhere('r.device = :device')
            ->setParameter('dateFrom', $dateFrom)
            ->setParameter('device', $device)
            ->orderBy('r.startedAt', Criteria::DESC)
            ->getQuery()
            ->setMaxResults(1)
            ->getOneOrNullResult();
    }

    /**
     * @param Device $device
     * @param \DateTimeInterface $dateFrom
     * @param \DateTimeInterface $dateTo
     * @return Route|null
     * @throws \Doctrine\ORM\NonUniqueResultException
     */
    public function getClosestNextRouteByDeviceAndDate(
        Device $device,
        \DateTimeInterface $dateFrom,
        \DateTimeInterface $dateTo
    ): ?Route {
        return $this->getEntityManager()
            ->createQueryBuilder()
            ->select('r')
            ->from(Route::class, 'r')
            ->where('r.startedAt >= :dateFrom')
            ->andWhere('r.startedAt < :dateTo')
            ->andWhere('r.device = :device')
            ->setParameter('dateFrom', $dateFrom)
            ->setParameter('dateTo', $dateTo)
            ->setParameter('device', $device)
            ->orderBy('r.startedAt', Criteria::ASC)
            ->getQuery()
            ->setMaxResults(1)
            ->getOneOrNullResult();
    }

    /**
     * @param int $deviceId
     * @param string $date
     * @return Route|null
     * @throws \Doctrine\ORM\NonUniqueResultException
     */
    public function getNextStopRoute(int $deviceId, string $date): ?Route
    {
        return $this->getEntityManager()
            ->createQueryBuilder()
            ->select('r')
            ->from(Route::class, 'r')
            ->andWhere('r.startedAt = :finishDate')
            ->andWhere('IDENTITY(r.device) = :deviceId')
            ->andWhere('r.type = :type')
            ->setParameter('finishDate', $date)
            ->setParameter('deviceId', $deviceId)
            ->setParameter('type', Route::TYPE_STOP)
            ->getQuery()
            ->setMaxResults(1)
            ->getOneOrNullResult();
    }

    /**
     * @param int $deviceId
     * @param $startDate
     * @param bool|null $excludeEqual
     * @return array|null
     */
    public function getLastRouteStartedFromDate(int $deviceId, $startDate, ?bool $excludeEqual = false): ?Route
    {
        $query = $this->getEntityManager()
            ->createQueryBuilder()
            ->select('r')
            ->from(Route::class, 'r')
            ->where('IDENTITY(r.device) = :deviceId')
            ->setParameter('deviceId', $deviceId)
            ->setParameter('startDate', $startDate)
            ->orderBy('r.startedAt', Criteria::DESC);

        $excludeEqual ? $query->andWhere('r.startedAt < :startDate') : $query->andWhere('r.startedAt <= :startDate');
        $result = $query->getQuery()
            ->setMaxResults(2)
            ->getResult();

        if ($result) {
            $route1 = $result[0];
            $route2 = $result[1] ?? null;
            $result = $route2 &&
            $route1->getStartedAt() === $route2->getStartedAt() &&
            $route2->getId() > $route1->getId()
                ? $route2
                : $route1;
        }

        return $result ?: null;
    }

    /**
     * @param int $deviceId
     * @param $startDate
     * @return array|null
     * @throws \Doctrine\ORM\NonUniqueResultException
     */
    public function getLastRouteStartedFromDateWithoutIncluding(int $deviceId, $startDate): ?Route
    {
        $qb = $this->getEntityManager()
            ->createQueryBuilder();

        return $qb->select('r')
            ->from(Route::class, 'r')
            ->where($qb->expr()->eq('IDENTITY(r.device)', $deviceId))
            ->andWhere('r.startedAt < :startDate')
            ->setParameter('startDate', $startDate)
            ->orderBy('r.startedAt', Criteria::DESC)
            ->getQuery()
            ->setMaxResults(1)
            ->getOneOrNullResult();
    }

    /**
     * @param int $deviceId
     * @param $dateFrom
     * @param $dateTo
     * @return int|null
     */
    public function removeNewestRoutesFromDate(int $deviceId, $dateFrom, $dateTo = null): ?int
    {
        $qb = $this->getEntityManager()
            ->createQueryBuilder();

        $query = $qb->delete(Route::class, 'r')
            ->where($qb->expr()->eq('IDENTITY(r.device)', $deviceId))
            ->andWhere('r.startedAt >= :dateFrom')
            ->setParameter('dateFrom', $dateFrom);

        if ($dateTo) {
            $query->andWhere('r.startedAt < :dateTo')
                ->setParameter('dateTo', $dateTo);
        }

        return $query->getQuery()->execute();
    }

    /**
     * @param Device $device
     * @param \DateTimeInterface|string|null $dateFrom
     * @param \DateTimeInterface|string|null $dateTo
     * @return mixed
     */
    public function removeDeviceRoutesByPeriod(Device $device, $dateFrom = null, $dateTo = null)
    {
        $query = $this->getEntityManager()
            ->createQueryBuilder()
            ->delete(Route::class, 'r')
            ->where('r.device = :device')
            ->setParameter('device', $device)
            ->andWhere('r.vehicle = :vehicle')
            ->setParameter('vehicle', $device->getVehicle());

        if ($dateFrom) {
            $query->andWhere('r.startedAt >= :dateFrom')
                ->setParameter('dateFrom', $dateFrom);
        }
        if ($dateTo) {
            $query->andWhere('r.startedAt < :dateTo')
                ->setParameter('dateTo', $dateTo);
        }

        return $query->getQuery()->execute();
    }

    /**
     * @param User $driver
     * @return array|null
     * @throws \Doctrine\ORM\NonUniqueResultException
     */
    public function getDriverLastRoute(User $driver): ?Route
    {
        return $this->getEntityManager()
            ->createQueryBuilder()
            ->select('r')
            ->from(Route::class, 'r')
            ->where('r.driver = :driver')
            ->setParameter('driver', $driver)
            ->orderBy('r.startedAt', Criteria::DESC)
            ->getQuery()
            ->setMaxResults(1)
            ->getOneOrNullResult();
    }

    /**
     * @param int $deviceId
     * @return array|null
     * @throws \Doctrine\ORM\NonUniqueResultException
     */
    public function getLastDeviceRoute(int $deviceId): ?Route
    {
        $qb = $this->getEntityManager()
            ->createQueryBuilder();

        return $qb->select('r')
            ->from(Route::class, 'r')
            ->where($qb->expr()->eq('IDENTITY(r.device)', $deviceId))
            ->orderBy('r.startedAt', Criteria::DESC)
            ->getQuery()
            ->setMaxResults(1)
            ->getOneOrNullResult();
    }

    /**
     * @param int $vehicleId
     * @return array|null
     * @throws \Doctrine\ORM\NonUniqueResultException
     */
    public function getLastVehicleRoute(int $vehicleId): ?Route
    {
        $qb = $this->getEntityManager()
            ->createQueryBuilder();

        return $qb->select('r')
            ->from(Route::class, 'r')
            ->where($qb->expr()->eq('IDENTITY(r.vehicle)', $vehicleId))
            ->orderBy('r.startedAt', Criteria::DESC)
            ->getQuery()
            ->setMaxResults(1)
            ->getOneOrNullResult();
    }

    /**
     * @param TrackerHistory $trackerHistory
     * @return string|null
     * @throws \Doctrine\ORM\NonUniqueResultException
     */
    public function getClosestAddressByDate(TrackerHistory $trackerHistory): ?string
    {
        $result = $this->getEntityManager()
            ->createQueryBuilder()
            ->select('r.address')
            ->from(Route::class, 'r')
            ->where('r.startedAt <= :date')
            ->andWhere('r.address IS NOT NULL')
            ->andWhere('r.vehicle = :vehicle')
            ->setParameter('date', $trackerHistory->getTs())
            ->setParameter('vehicle', $trackerHistory->getVehicle())
            ->orderBy('r.startedAt', Criteria::DESC)
            ->getQuery()
            ->setMaxResults(1)
            ->getOneOrNullResult();

        return $result ? $result['address'] : null;
    }

    /**
     * @param RouteReportDTO $params
     * @param bool $getVehiclesList
     * @return mixed
     */
    public function getRoutesSummary(RouteReportDTO $params, bool $getVehiclesList = false)
    {
        $isNewAreaReport = $params->startDate > Carbon::parse('2024-02-31');

        $em = $this->getEntityManager();
        $qb = $em->createQueryBuilder();

        $asTable = $em->getClassMetadata(RouteStartArea::class)->getTableName();
        $afTable = $em->getClassMetadata(RouteFinishArea::class)->getTableName();
        $rTable = $em->getClassMetadata(Route::class)->getTableName();
        $aTable = $em->getClassMetadata(Area::class)->getTableName();
        $vgTable = $em->getClassMetadata(VehicleGroup::class)->getTableName();
        $vTable = $em->getClassMetadata(Vehicle::class)->getTableName();
        $depotTable = $em->getClassMetadata(Depot::class)->getTableName();
        $driverTable = $em->getClassMetadata(User::class)->getTableName();
        $voTable = $em->getClassMetadata(VehicleOdometer::class)->getTableName();

        $startAreaGroupsSubQuery = $em->getConnection()->createQueryBuilder()
            ->select('string_agg(agstart.name, \', \') AS ag_start_name, r.id as r_id')
            ->from($rTable, 'r')
            ->innerJoin('r', $vTable, 'v', 'r.vehicle_id = v.id')
            ->leftJoin('r', $aTable, 'a_start',
                'ST_Contains(a_start.polygon, r.start_coordinates) = true AND a_start.status = :areaStatus AND a_start.team_id IN (' . implode(', ',
                    $params->teamId) . ')')
            ->leftJoin('a_start', 'areas_groups', 'agsstart', 'a_start.id = agsstart.area_id')
            ->leftJoin('agsstart', 'area_group', 'agstart', 'agsstart.area_group_id = agstart.id')
            ->andWhere(
                $qb->expr()->andX(
                    $qb->expr()->lte('r.started_at', ':dateTo'),
                    $qb->expr()->gte('r.finished_at', ':dateFrom')
                )
            )
            ->groupBy('r.id');

        if ($params->teamId) {
            $startAreaGroupsSubQuery->andWhere('a_start.team_id IN (' . implode(', ', $params->teamId) . ')');
            $startAreaGroupsSubQuery->andWhere('v.team_id IN (' . implode(', ', $params->teamId) . ')');
        }

        $finishAreaGroupsSubQuery = $em->getConnection()->createQueryBuilder()
            ->select('string_agg(agfinish.name, \', \') AS ag_finish_name, r.id as r_id')
            ->from($rTable, 'r')
            ->innerJoin('r', $vTable, 'v', 'r.vehicle_id = v.id')
            ->leftJoin('r', $aTable, 'a_finish',
                'ST_Contains(a_finish.polygon, r.finish_coordinates) = true AND a_finish.status = :areaStatus AND a_finish.team_id IN (' . implode(', ',
                    $params->teamId) . ')')
            ->leftJoin('a_finish', 'areas_groups', 'agsfinish', 'a_finish.id = agsfinish.area_id')
            ->leftJoin('agsfinish', 'area_group', 'agfinish', 'agsfinish.area_group_id = agfinish.id')
            ->andWhere(
                $qb->expr()->andX(
                    $qb->expr()->lte('r.started_at', ':dateTo'),
                    $qb->expr()->gte('r.finished_at', ':dateFrom')
                )
            )
            ->groupBy('r.id');

        if ($params->teamId) {
            $finishAreaGroupsSubQuery->andWhere('a_finish.team_id IN (' . implode(', ', $params->teamId) . ')');
            $finishAreaGroupsSubQuery->andWhere('v.team_id IN (' . implode(', ', $params->teamId) . ')');
        }

        $groupsSubQuery = $em->getConnection()->createQueryBuilder()
            ->select('string_agg(vg.name, \', \') AS groups, vgs.vehicle_id')
            ->from('vehicles_groups', 'vgs')
            ->leftJoin('vgs', $vgTable, 'vg', 'vg.id =vgs.vehicle_group_id')
            ->groupBy('vgs.vehicle_id');

        $addressFromSubQuery = $em->getConnection()->createQueryBuilder()
            ->select('r.address as address_from, r.point_finish_id as pointFinish')
            ->from($rTable, 'r')
            ->andWhere('r.type = :stopped')
            ->setParameter('stopped', Route::TYPE_STOP, Types::STRING);

        $addressToSubQuery = $em->getConnection()->createQueryBuilder()
            ->select('r.address as address_to, r.point_start_id as pointStart')
            ->from($rTable, 'r')
            ->andWhere('r.type = :stopped')
            ->setParameter('stopped', Route::TYPE_STOP, Types::STRING);

        $parkingRouteSubQuery = $em->getConnection()->createQueryBuilder()
            ->select('r.point_start_id as pointStart, extract(epoch from (r.finished_at::timestamp - r.started_at::timestamp))::INT as parking_time')
            ->from($rTable, 'r')
            ->andWhere('r.type = :stopped')
            ->setParameter('stopped', Route::TYPE_STOP, Types::STRING);

        if ($params->vehicleId) {
            $addressFromSubQuery->andWhere('r.vehicle_id = :vehicleId')->setParameter('vehicleId', $params->vehicleId);
            $addressToSubQuery->andWhere('r.vehicle_id = :vehicleId')->setParameter('vehicleId', $params->vehicleId);
        }

        if ($params->vehicleIds) {
            $addressFromSubQuery->andWhere('r.vehicle_id IN (' . implode(', ', $params->vehicleIds) . ')');
            $addressToSubQuery->andWhere('r.vehicle_id IN (' . implode(', ', $params->vehicleIds) . ')');
        }

//        $odometerQb = $em->getRepository(VehicleOdometer::class)->getLastOdometerCorrectionQueryBuilder();

        $maxOdometerDateQuery = $em->getConnection()->createQueryBuilder()
            ->select('max(vo.occurred_at) as max_occurred_at, vo.vehicle_id')
            ->from($voTable, 'vo')
            ->andWhere('vo.accuracy IS NOT NULL')
            ->groupBy('vo.vehicle_id');

        $query = $this
            ->getEntityManager()
            ->getConnection()
            ->createQueryBuilder()
            ->from($rTable, 'r')
            ->leftJoin('r', $driverTable, 'd', 'r.driver_id = d.id')
            ->leftJoin('r', $vTable, 'v', 'r.vehicle_id = v.id')
            ->leftJoin('v', $depotTable, 'depot', 'v.depot_id = depot.id')
            ->leftJoin('v', sprintf('(%s)', $groupsSubQuery->getSQL()), 'vgs', 'vgs.vehicle_id = v.id')
            ->leftJoin(
                'r',
                sprintf('(%s)', $addressFromSubQuery->getSQL()),
                'r_from',
                'r_from.pointFinish = r.point_start_id'
            )
            ->leftJoin(
                'r',
                sprintf('(%s)', $addressToSubQuery->getSQL()),
                'r_to',
                'r_to.pointStart = r.point_finish_id'
            )
//            ->leftJoin('r', sprintf('(%s)', $startAreaGroupsSubQuery->getSQL()), 'agstart', 'r.id = agstart.r_id')
//            ->leftJoin('r', sprintf('(%s)', $finishAreaGroupsSubQuery->getSQL()), 'agfinish', 'r.id = agfinish.r_id')
//            ->leftJoin('r', $aTable, 'a_start',
//                'ST_Contains(a_start.polygon, r.start_coordinates) = true AND a_start.status = :areaStatus AND a_start.team_id IN (' . implode(', ',
//                    $params->teamId) . ')')
//            ->leftJoin('r', $aTable, 'a_finish',
//                'ST_Contains(a_finish.polygon, r.finish_coordinates) = true AND a_finish.status = :areaStatus AND a_finish.team_id IN (' . implode(', ',
//                    $params->teamId) . ')')
            ->leftJoin('a_start', 'areas_groups', 'agsstart', 'a_start.id = agsstart.area_id')
            ->leftJoin('agsstart', 'area_group', 'ag_start', 'agsstart.area_group_id = ag_start.id')
            ->leftJoin('a_finish', 'areas_groups', 'agsfinish', 'a_finish.id = agsfinish.area_id')
            ->leftJoin('agsfinish', 'area_group', 'ag_finish', 'agsfinish.area_group_id = ag_finish.id')
            ->leftJoin(
                'r',
                sprintf('(%s)', $parkingRouteSubQuery->getSQL()),
                'parking_route',
                'parking_route.pointStart = r.point_finish_id'
            )
//            ->leftJoin('v', sprintf('(%s)', $odometerQb->getSQL()), 'vo', 'vo.vehicle_id = v.id')
            ->andWhere('r.type = :type')
            ->andWhere('v.status <> :vehicleDeleted')
            ->setParameter('dateFrom', $params->startDate)
            ->setParameter('dateTo', $params->endDate)
            ->setParameter('type', Route::TYPE_DRIVING)
            ->setParameter('stopped', Route::TYPE_STOP, Types::STRING)
            ->setParameter('areaStatus', Area::STATUS_ACTIVE)
            ->setParameter('vehicleDeleted', Vehicle::STATUS_DELETED)
            ->setParameter('typeIdling', RouteTemp::TYPE_IDLING);

        if ($isNewAreaReport) {
            $query->leftJoin('r', $asTable, 'route_start_area', 'route_start_area.route_id = r.id')
                ->leftJoin('r', $afTable, 'route_finish_area', 'route_finish_area.route_id = r.id')
                ->leftJoin('r', $aTable, 'a_start', 'a_start.id = route_start_area.area_id')
                ->leftJoin('r', $aTable, 'a_finish', 'a_finish.id = route_finish_area.area_id');
        } else {
            $query
                ->leftJoin('r', sprintf('(%s)', $startAreaGroupsSubQuery->getSQL()), 'agstart', 'r.id = agstart.r_id')
                ->leftJoin('r', sprintf('(%s)', $finishAreaGroupsSubQuery->getSQL()), 'agfinish',
                    'r.id = agfinish.r_id')->leftJoin('r', $aTable, 'a_start',
                    'ST_Contains(a_start.polygon, r.start_coordinates) = true AND a_start.status = :areaStatus AND a_start.team_id IN (' . implode(', ',
                        $params->teamId) . ')')
                ->leftJoin('r', $aTable, 'a_finish',
                    'ST_Contains(a_finish.polygon, r.finish_coordinates) = true AND a_finish.status = :areaStatus AND a_finish.team_id IN (' . implode(', ',
                        $params->teamId) . ')');
        }

        if ($params->reportRoutesCorrectedOnly) {
            $query->innerJoin('v', sprintf('(%s)', $maxOdometerDateQuery->getSQL()), 'mvod', 'mvod.vehicle_id = v.id');
            $query->andWhere('r.finished_at <= mvod.max_occurred_at');
        }

        if ($getVehiclesList) {
            $query->addSelect('v.id')
                ->addSelect(
                    [
                        'SUM (r.distance) as distance_total',
                        'SUM (r.total_movement_duration) as driving_time_total',
                        'SUM (r.total_idle_duration) as idling_time_total',
                        'SUM (parking_route.parking_time) as parking_time_total'

                    ]
                )->groupBy('v.id');
        } else {
            $query->addSelect('v.regNo, v.defaultLabel, v.model')
                ->addSelect('(CASE WHEN d.name IS NULL THEN null ELSE CONCAT(d.name, \' \', d.surname) END) as driver_name, d.id as driver_id')
                ->addSelect('vgs.groups')
                ->addSelect('depot.name as depot_name, depot.id as depotId')
                ->addSelect(
                    'r.id as route_id, to_char (r.started_at, \'YYYY-MM-DD"T"HH24:MI:SS"+00:00"\') as started_at',
                    'r_from.address_from'
                );

            if ($isNewAreaReport) {
                $query
                    ->addSelect('string_agg(DISTINCT a_start.name, \', \') as start_areas_name')
                    ->addSelect('STRING_AGG(DISTINCT ag_start.name, \', \') as start_areas_group_name');
            } else {
                $query
                    ->addSelect('string_agg(DISTINCT a_start.name, \', \') as start_areas_name')
                    ->addSelect('agstart.ag_start_name as start_areas_group_name');
            }

            $query->addSelect(
                'to_char (r.finished_at, \'YYYY-MM-DD"T"HH24:MI:SS"+00:00"\') as finished_at, r_to.address_to'
            );

            if ($isNewAreaReport) {
                $query
                    ->addSelect('string_agg(DISTINCT a_finish.name, \', \') as finish_areas_name')
                    ->addSelect('STRING_AGG(DISTINCT ag_finish.name, \', \') as finish_areas_group_name');
            } else {
                $query
                    ->addSelect('agfinish.ag_finish_name as finish_areas_group_name')
                    ->addSelect('string_agg(DISTINCT a_finish.name, \', \') as finish_areas_name');
            }

            $query->addSelect('r.distance')
                ->addSelect('r.total_movement_duration as driving_time')
                ->addSelect('r.total_idle_duration as idling_time')
                ->addSelect('parking_route.parking_time as parking_time')
                ->addSelect('r.avg_speed, r.max_speed')
                ->addSelect('r.trip_code')
                ->addSelect(
                    [
                        '(SUM (r.distance) OVER ()) as distance_total',
                        '(MIN (r.start_odometer) OVER ()) as start_odometer_total',
                        '(MAX (r.finish_odometer) OVER ()) as finish_odometer_total',
                        '(SUM (r.total_movement_duration) OVER ()) as driving_time_total',
                        '(ROUND (AVG (r.avg_speed) OVER (), 1)) as avg_speed_total',
                        '(MAX (r.max_speed) OVER ()) as max_speed_total',
                        '(SUM (r.total_idle_duration) OVER ()) as idling_time_total',
                        '(SUM (parking_route.parking_time) OVER ()) as parking_time_total',
                    ]
                )
                ->addSelect(
                    'COALESCE(get_v_last_accuracy(v.id, r.started_at),0) + COALESCE(r.start_odometer,0) AS start_odometer',
                    'COALESCE(get_v_last_accuracy(v.id, r.finished_at),0) + COALESCE(r.finish_odometer,0) AS finish_odometer'
                )
                ->orderBy($params->sort, $params->order . ' NULLS LAST');

            if ($isNewAreaReport) {
                $query->groupBy('v.regNo, v.id, d.id, v.defaultLabel, v.model, driver_name, vgs.groups, depotId, r.id,
                r_from.address_from, r_to.address_to, parking_time,
                COALESCE(get_v_last_accuracy(v.id, r.started_at), 0) + COALESCE(r.start_odometer, 0), COALESCE(get_v_last_accuracy(v.id, r.finished_at), 0) + COALESCE(r.finish_odometer, 0)');
            } else {
                $query->groupBy('v.regNo, v.id, d.id, v.defaultLabel, v.model, driver_name, vgs.groups, depotId, r.id,
                r_from.address_from, r_to.address_to, parking_time,
                COALESCE(get_v_last_accuracy(v.id, r.started_at), 0) + COALESCE(r.start_odometer, 0), COALESCE(get_v_last_accuracy(v.id, r.finished_at), 0) + COALESCE(r.finish_odometer, 0), agstart.ag_start_name, agfinish.ag_finish_name');
            }
        }

        $query->andWhere(
            $qb->expr()->andX(
                $qb->expr()->lte('r.started_at', ':dateTo'),
                $qb->expr()->gte('r.finished_at', ':dateFrom')
            )
        );

        if ($params->defaultLabel) {
            if (is_array($params->defaultLabel)) {
                $q = [];
                foreach ($params->defaultLabel as $index => $label) {
                    $q[] = $qb->expr()->like('LOWER(v.defaultLabel)', ":label$index");
                    $query->setParameter("label$index", strtolower($label) . '%');
                }
                $query->andWhere(new Orx($q));
            } else {
                $query->andWhere('LOWER(v.defaultLabel) LIKE LOWER(:defaultLabel)')
                    ->setParameter('defaultLabel', $params->defaultLabel . '%');
            }
        }

        if ($params->vehicleRegNo) {
            $query->andWhere('LOWER(v.regNo) LIKE LOWER(:regNo)')
                ->setParameter('regNo', $params->vehicleRegNo . '%');
        }

        if ($params->driver) {
            $query->andWhere('LOWER(CONCAT(d.name, \' \', d.surname)) LIKE LOWER(:driverName)')
                ->setParameter('driverName', $params->driver . '%');
        }

        if ($params->vehicleDepot) {
            $query->andWhere('depot_id = :depotId')->setParameter('depotId', $params->vehicleDepot);
        }

        if ($params->driverId) {
            $query->andWhere('d.id IN (:driverId)')
                ->setParameter('driverId', $params->driverId, Connection::PARAM_INT_ARRAY);
        }

        if ($params->vehicleId) {
            $query->andWhere('r.vehicle_id = :vehicleId')->setParameter('vehicleId', $params->vehicleId);
        }

        if ($params->vehicleIds) {
            $query->andWhere('r.vehicle_id IN (' . implode(', ', $params->vehicleIds) . ')');
        }

        if ($params->tripCode) {
            $query->andWhere('r.trip_code = :tripCode')
                ->setParameter('tripCode', $params->tripCode);
        }

        $query = $this->addDepotIdFilter($query, $params->depotId, $params->noDepot);
        $query = $this->addGroupsFilter($query, $params->vehicleGroup, $params->noGroups);

        $query = $this->addAreaGroupsFilter(
            $query, $params->areaGroupStart, $params->noAreaGroupStart, 'ag_start', 'agstart');
        $query = $this->addAreaGroupsFilter(
            $query, $params->areaGroupFinish, $params->noAreaGroupFinish, 'ag_finish', 'agfinish');

        $query = $this->addAreaFilter($query, $params->areaFrom, $params->noAreaFrom, 'a_start');
        $query = $this->addAreaFilter($query, $params->areaTo, $params->noAreaTo, 'a_finish');

        if ($params->teamId) {
            $query->andWhere('v.team_id IN (' . implode(', ', $params->teamId) . ')')
                ->setParameter('teamId', $params->teamId);
        }

        return $query;
    }

    /**
     * @param FbtReportDTO $params
     * @param $getVehiclesList
     * @return mixed
     */
    public function getRoutesFbt(FbtReportDTO $params, $getVehiclesList = false)
    {
        $isNewAreaReport = $params->startDate > Carbon::parse('2024-02-31');

        $em = $this->getEntityManager();
        $qb = $em->createQueryBuilder();

        $rTable = $em->getClassMetadata(Route::class)->getTableName();
        $aTable = $em->getClassMetadata(Area::class)->getTableName();
        $asTable = $em->getClassMetadata(RouteStartArea::class)->getTableName();
        $afTable = $em->getClassMetadata(RouteFinishArea::class)->getTableName();
        $agTable = $em->getClassMetadata(AreaGroup::class)->getTableName();
        $vgTable = $em->getClassMetadata(VehicleGroup::class)->getTableName();
        $vTable = $em->getClassMetadata(Vehicle::class)->getTableName();
        $depotTable = $em->getClassMetadata(Depot::class)->getTableName();
        $driverTable = $em->getClassMetadata(User::class)->getTableName();
        $voTable = $em->getClassMetadata(VehicleOdometer::class)->getTableName();

        $groupsSubQuery = $em->getConnection()->createQueryBuilder()
            ->select('string_agg(vg.name, \', \') AS groups, vgs.vehicle_id')
            ->from('vehicles_groups', 'vgs')
            ->leftJoin('vgs', $vgTable, 'vg', 'vg.id =vgs.vehicle_group_id')
            ->groupBy('vgs.vehicle_id');

        $parkingRouteSubQuery = $em->getConnection()->createQueryBuilder()
            ->select('r.point_start_id as pointStart, extract(epoch from (r.finished_at::timestamp - r.started_at::timestamp))::INT as parking_time')
            ->from($rTable, 'r')
            ->andWhere('r.type = :stopped')
            ->setParameter('stopped', Route::TYPE_STOP, Types::STRING);

        $maxOdometerDateQuery = $em->getConnection()->createQueryBuilder()
            ->select('max(vo.occurred_at) as max_occurred_at, vo.vehicle_id')
            ->from($voTable, 'vo')
            ->andWhere('vo.accuracy IS NOT NULL')
            ->groupBy('vo.vehicle_id');

        $finishOdometerSubQuery = $em->getConnection()->createQueryBuilder()
            ->select('rs.point_start_id as stop_start_point_id, rr.start_odometer as next_driving_start_odometer')
            ->from($rTable, 'rr')
            ->leftJoin('rr', $rTable, 'rs', 'rr.point_start_id = rs.point_finish_id');

        $query = $this
            ->getEntityManager()
            ->getConnection()
            ->createQueryBuilder()
            ->from($rTable, 'r')
            ->leftJoin('r', $driverTable, 'd', 'r.driver_id = d.id')
            ->innerJoin('r', $vTable, 'v', 'r.vehicle_id = v.id')
            ->leftJoin('v', $depotTable, 'depot', 'v.depot_id = depot.id')
            ->leftJoin(
                'v',
                sprintf('(%s)', $groupsSubQuery->getSQL()),
                'vgs',
                'vgs.vehicle_id = v.id'
            )
            ->leftJoin(
                'r',
                sprintf('(%s)', $parkingRouteSubQuery->getSQL()),
                'parking_route',
                'parking_route.pointStart = r.point_finish_id'
            )
            ->leftJoin(
                'r',
                sprintf('(%s)', $finishOdometerSubQuery->getSQL()),
                'next_route',
                'next_route.stop_start_point_id = r.point_finish_id'
            )
            ->andWhere('r.type = :type')
            ->andWhere('v.status <> :vehicleDeleted')
            ->setParameter('vehicleDeleted', Vehicle::STATUS_DELETED)
            ->setParameter('dateFrom', $params->startDate)
            ->setParameter('dateTo', $params->endDate)
            ->setParameter('type', Route::TYPE_DRIVING)
            ->setParameter('stopped', Route::TYPE_STOP, Types::STRING)
            ->setParameter('areaStatus', Area::STATUS_ACTIVE)
            ->setParameter('typeIdling', RouteTemp::TYPE_IDLING);

        if ($isNewAreaReport) {
            $query->leftJoin('r', $asTable, 'route_start_area', 'route_start_area.route_id = r.id')
                ->leftJoin('r', $afTable, 'route_finish_area', 'route_finish_area.route_id = r.id')
                ->leftJoin('r', $aTable, 'a_start', 'a_start.id = route_start_area.area_id')
                ->leftJoin('r', $aTable, 'a_finish', 'a_finish.id = route_finish_area.area_id')
                ->leftJoin('a_start', 'areas_groups', 'agsstart', 'a_start.id = agsstart.area_id')
                ->leftJoin('agsstart', 'area_group', 'ag_start', 'agsstart.area_group_id = ag_start.id')
                ->leftJoin('a_finish', 'areas_groups', 'agsfinish', 'a_finish.id = agsfinish.area_id')
                ->leftJoin('agsfinish', 'area_group', 'ag_finish', 'agsfinish.area_group_id = ag_finish.id');
        }

        if ($params->reportRoutesCorrectedOnly) {
            $query->innerJoin('v', sprintf('(%s)', $maxOdometerDateQuery->getSQL()), 'mvod', 'mvod.vehicle_id = v.id');
            $query->andWhere('r.finished_at <= mvod.max_occurred_at');
        }

        if ($getVehiclesList) {
            $query->select('v.id')->groupBy('v.id');
        } else {
            $query->select('v.defaultLabel, v.regNo, v.model')
                ->addSelect('(CASE WHEN d.name IS NULL THEN null ELSE CONCAT(d.name, \' \', d.surname) END) as driver_name')
                ->addSelect('vgs.groups')
                ->addSelect('depot.name as depot_name, depot.id as depotId')
                ->addSelect('r.id as route_id, to_char (r.started_at, \'YYYY-MM-DD"T"HH24:MI:SS"+00:00"\') as started_at')
                ->addSelect('to_char (r.finished_at, \'YYYY-MM-DD"T"HH24:MI:SS"+00:00"\') as finished_at')
                ->addSelect('get_route_start_address(r.point_start_id, r.device_id) as address_from');

            if ($isNewAreaReport) {
                $query->addSelect('string_agg(DISTINCT a_start.name, \', \') as start_areas_name')
                    ->addSelect('STRING_AGG(DISTINCT ag_start.name, \', \') as start_areas_group_name');
            } else {
                $query->addSelect('get_area_by_ts_vehicle(r.started_at, v.id)  as start_areas_name')
                    ->addSelect('get_area_group_by_ts_vehicle(r.started_at, v.id) as start_areas_group_name');
            }

            $query->addSelect('get_route_finish_address(r.point_finish_id, r.device_id) as address_to');

            if ($isNewAreaReport) {
                $query->addSelect('string_agg(DISTINCT a_finish.name, \', \') as finish_areas_name')
                    ->addSelect('STRING_AGG(DISTINCT ag_finish.name, \', \') as finish_areas_group_name');
            } else {
                $query->addSelect('get_area_by_ts_vehicle(r.finished_at, v.id) as finish_areas_name')
                    ->addSelect('get_area_group_by_ts_vehicle(r.finished_at, v.id) as finish_areas_group_name');
            }

            $query->addSelect('case when ((COALESCE(next_route.next_driving_start_odometer, r.finish_odometer, 0) - COALESCE(r.finish_odometer,0)) > (COALESCE(r.finish_odometer,0) - COALESCE(r.start_odometer,0)) 
                OR (COALESCE(r.start_odometer, 0) > COALESCE(next_route.next_driving_start_odometer, r.finish_odometer, 0)))
                then (COALESCE(r.finish_odometer, 0) - COALESCE(r.start_odometer,0))::BIGINT
                else (COALESCE(next_route.next_driving_start_odometer, r.finish_odometer, 0) - COALESCE(r.start_odometer,0))::BIGINT end as distance')
                ->addSelect('r.total_movement_duration as driving_time')
                ->addSelect('r.total_idle_duration as idling_time')
                ->addSelect('parking_route.parking_time as parking_time')
                ->addSelect('r.avg_speed, r.max_speed')
                ->addSelect('r.scope, r.comment')
                ->addSelect('r.trip_code')
                ->addSelect(
                    [
                        '(SUM (case when ((COALESCE(next_route.next_driving_start_odometer, r.finish_odometer, 0) - COALESCE(r.finish_odometer,0)) > (COALESCE(r.finish_odometer,0) - COALESCE(r.start_odometer,0))
                         OR (COALESCE(r.start_odometer, 0) > COALESCE(next_route.next_driving_start_odometer, r.finish_odometer, 0)))
                then (COALESCE(r.finish_odometer, 0) - COALESCE(r.start_odometer,0))::BIGINT
                else (COALESCE(next_route.next_driving_start_odometer, r.finish_odometer, 0) - COALESCE(r.start_odometer,0))::BIGINT end) OVER ())::BIGINT as distance_total',
                        '(SUM (r.total_movement_duration) OVER ()) as driving_time_total',
                        '(SUM (parking_route.parking_time) OVER ()) as parking_time_total',
                    ]
                )
                ->groupBy('v.regNo, v.defaultLabel, v.model, driver_name, vgs.groups, depotId, r.id, 
                 parking_time,
                next_route.next_driving_start_odometer, next_route.stop_start_point_id')
                ->orderBy($params->sort, $params->order . ' NULLS LAST');
        }

        if ($isNewAreaReport) {
            $query = $this->addAreaGroupsFilter(
                $query, $params->areaGroupStart, $params->noAreaGroupStart, 'ag_start', 'agstart');
            $query = $this->addAreaGroupsFilter(
                $query, $params->areaGroupFinish, $params->noAreaGroupFinish, 'ag_finish', 'agfinish');

            $query = $this->addAreaFilter($query, $params->areaFrom, $params->noAreaFrom, 'a_start');
            $query = $this->addAreaFilter($query, $params->areaTo, $params->noAreaTo, 'a_finish');

        } else {
            if ($params->noAreaGroupStart) {
                $query->andWhere('get_area_group_by_ts_vehicle(r.started_at, v.id) is NULL');
            }
            if ($params->areaGroupStart) {
                foreach ($params->areaGroupStart as $ag) {
                    $query->andWhere('get_area_group_id_by_ts_vehicle(r.started_at, v.id) LIKE \'%' . $ag . '%\'');
                }
            }

            if ($params->noAreaGroupFinish) {
                $query->andWhere('get_area_group_by_ts_vehicle(r.finished_at, v.id) is NULL');
            }
            if ($params->areaGroupFinish) {
                foreach ($params->areaGroupFinish as $ag) {
                    $query->andWhere('get_area_group_id_by_ts_vehicle(r.finished_at, v.id) LIKE  \'%' . $ag . '%\'');
                }
            }

            if ($params->noAreaFrom) {
                $query->andWhere('get_area_by_ts_vehicle(r.started_at, v.id) is NULL');
            }
            if ($params->areaFrom) {
                foreach ($params->areaFrom as $a) {
                    $query->andWhere('get_area_id_by_ts_vehicle(r.started_at, v.id) LIKE  \'%' . $a . '%\'');
                }
            }

            if ($params->noAreaTo) {
                $query->andWhere('get_area_by_ts_vehicle(r.finished_at, v.id) is NULL');
            }
            if ($params->areaTo) {
                foreach ($params->areaTo as $a) {
                    $query->andWhere('get_area_id_by_ts_vehicle(r.finished_at, v.id) LIKE \'%' . $a . '%\'');
                }
            }
        }

        if ($params->withoutCorrection) {
            $query->addSelect(
                'COALESCE(r.start_odometer,0)::BIGINT AS start_odometer',
                'COALESCE(next_route.next_driving_start_odometer, r.finish_odometer, 0) AS finish_odometer'
            )->addGroupBy([
                'COALESCE(r.start_odometer, 0)',
                'COALESCE(next_route.next_driving_start_odometer, r.finish_odometer, 0)'
            ]);
        } else {
            $query->addSelect(
                '(COALESCE(get_v_last_accuracy(v.id, r.started_at), 0) + COALESCE(r.start_odometer,0))::BIGINT AS start_odometer',
                'COALESCE(get_v_last_accuracy(v.id, r.finished_at), 0) + (case when ((COALESCE(next_route.next_driving_start_odometer, r.finish_odometer, 0) - COALESCE(r.finish_odometer,0)) > (COALESCE(r.finish_odometer,0) - COALESCE(r.start_odometer,0))
                 OR (COALESCE(r.start_odometer, 0) > COALESCE(next_route.next_driving_start_odometer, r.finish_odometer, 0)))
                then COALESCE(r.finish_odometer, 0)::BIGINT
                else COALESCE(next_route.next_driving_start_odometer, r.finish_odometer, 0)::BIGINT end) AS finish_odometer'
            )->addGroupBy([
                'v.id',
                'COALESCE(get_v_last_accuracy(v.id, r.started_at), 0) + COALESCE(r.start_odometer, 0)',
                'COALESCE(get_v_last_accuracy(v.id, r.started_at), 0) + (case when ((COALESCE(next_route.next_driving_start_odometer, r.finish_odometer, 0) - COALESCE(r.finish_odometer,0)) > (COALESCE(r.finish_odometer,0) - COALESCE(r.start_odometer,0)))
                then COALESCE(r.finish_odometer, 0)::BIGINT
                else COALESCE(next_route.next_driving_start_odometer, r.finish_odometer, 0)::BIGINT end)'
            ]);
        }

        $query->andWhere(
            $qb->expr()->andX(
                $qb->expr()->lte('r.started_at', ':dateTo'),
                $qb->expr()->gte('r.finished_at', ':dateFrom')
            )
        );

        if ($params->vehicleDefaultLabel) {
            if (is_array($params->vehicleDefaultLabel)) {
                $q = [];
                foreach ($params->vehicleDefaultLabel as $index => $label) {
                    $q[] = $qb->expr()->like('LOWER(v.defaultLabel)', ":label$index");
                    $query->setParameter("label$index", strtolower($label) . '%');
                }
                $query->andWhere(new Orx($q));
            } else {
                $query->andWhere('LOWER(v.defaultLabel) LIKE LOWER(:defaultLabel)')
                    ->setParameter('defaultLabel', $params->vehicleDefaultLabel . '%');
            }
        }

        if ($params->vehicleRegNo) {
            $query->andWhere('LOWER(v.regNo) LIKE LOWER(:regNo)')
                ->setParameter('regNo', $params->vehicleRegNo . '%');
        }

        if ($params->driver) {
            $query->andWhere('LOWER(CONCAT(d.name, \' \', d.surname)) LIKE LOWER(:driverName)')
                ->setParameter('driverName', $params->driver . '%');
        }

        if ($params->vehicleDepot) {
            $query->andWhere('depot_id = :depotId')->setParameter('depotId', $params->vehicleDepot);
        }

        if ($params->driverId) {
            $query->andWhere('d.id IN (:driverId)')
                ->setParameter('driverId', $params->driverId, Connection::PARAM_INT_ARRAY);
        }

        if ($params->vehicleId) {
            $query->andWhere('r.vehicle_id = :vehicleId')->setParameter('vehicleId', $params->vehicleId);
        }

        if ($params->vehicleIds) {
            $query->andWhere('r.vehicle_id IN (' . implode(', ', $params->vehicleIds) . ')');
        }

        if ($params->tripCode) {
            $query->andWhere('r.trip_code = :tripCode')->setParameter('tripCode', $params->tripCode);
        }

        if ($params->scope !== false) {
            if ($params->scope === Route::SCOPE_UNCATEGORISED) {
                $query->andWhere('r.scope IS NULL');
            } else {
                $query->andWhere('LOWER(r.scope) LIKE LOWER(:scope)')
                    ->setParameter('scope', $params->scope);
            }
        }

        $query = $this->addDepotIdFilter($query, $params->depotId, $params->noDepot);
        $query = $this->addGroupsFilter($query, $params->vehicleGroup, $params->noGroups);

        if ($params->teamId) {
            $query->andWhere('v.team_id IN (' . implode(', ', $params->teamId) . ')')
                ->setParameter('teamId', $params->teamId);
        }

        return $query;
    }

    public function getRoutesVehicleFbt(FbtVehicleReportDTO $params)
    {
        $connection = $this->getEntityManager()->getConnection();
        $driverTable = $this->getEntityManager()->getClassMetadata(User::class)->getTableName();
        $vTable = $this->getEntityManager()->getClassMetadata(Vehicle::class)->getTableName();
        $rTable = $this->getEntityManager()->getClassMetadata(Route::class)->getTableName();

        $finishOdometerSubQuery = $this->getEntityManager()->getConnection()->createQueryBuilder()
            ->select('rs.point_start_id as stop_start_point_id, rr.start_odometer as next_driving_start_odometer')
            ->from($rTable, 'rr')
            ->leftJoin('rr', $rTable, 'rs', 'rr.point_start_id = rs.point_finish_id');

        $routeQb = $connection->createQueryBuilder();
        $routeQb
            ->select(
                [
                    'r.vehicle_id',
                    'string_agg(DISTINCT CASE WHEN d.name IS NULL THEN null ELSE CONCAT(d.name, \' \', d.surname) END, \', \') as driver_name',
//                    'SUM(CASE WHEN r.type=:driving THEN (COALESCE(next_route.next_driving_start_odometer, r.finish_odometer, 0) - COALESCE(r.start_odometer,0)) END)::BIGINT AS total_distance',
//                    'SUM(CASE WHEN r.type=:driving AND r.scope IS NULL THEN (COALESCE(next_route.next_driving_start_odometer, r.finish_odometer, 0) - COALESCE(r.start_odometer,0)) END)::BIGINT AS unclassified_distance',
                    'SUM(CASE WHEN r.type=:driving THEN EXTRACT(EPOCH FROM (r.finished_at - r.started_at)) END)::BIGINT AS total_duration',
//                    'SUM(CASE WHEN r.type=:driving AND r.scope=:private THEN (COALESCE(next_route.next_driving_start_odometer, r.finish_odometer, 0) - COALESCE(r.start_odometer,0)) END)::BIGINT AS private_distance',
//                    'SUM(CASE WHEN r.type=:driving AND r.scope=:work THEN (COALESCE(next_route.next_driving_start_odometer, r.finish_odometer, 0) - COALESCE(r.start_odometer,0)) END)::BIGINT AS work_distance',
                    'SUM(CASE WHEN r.type=:driving AND r.scope=:work THEN EXTRACT(EPOCH FROM (r.finished_at - r.started_at)) END)::BIGINT AS work_duration',
                    'SUM(CASE WHEN r.type=:driving AND r.scope=:private THEN EXTRACT(EPOCH FROM (r.finished_at - r.started_at)) END)::BIGINT AS private_duration',
                    'SUM(CASE WHEN r.type=:driving AND r.scope IS NULL THEN EXTRACT(EPOCH FROM (r.finished_at - r.started_at)) END)::BIGINT AS unclassified_duration',
                    'MIN(r.started_at) as min_started_at',
                    'MAX(r.finished_at) as max_finished_at',
                ]
            )
            ->addSelect('SUM(CASE WHEN r.type=:driving AND r.scope=:work
            THEN (CASE WHEN ((COALESCE(next_route.next_driving_start_odometer, r.finish_odometer, 0) - COALESCE(r.finish_odometer,0)) > (COALESCE(r.finish_odometer,0) - COALESCE(r.start_odometer,0)) 
            OR (COALESCE(r.start_odometer, 0) > COALESCE(next_route.next_driving_start_odometer, r.finish_odometer, 0)))
                then (COALESCE(r.finish_odometer, 0) - COALESCE(r.start_odometer,0))::BIGINT
                else (COALESCE(next_route.next_driving_start_odometer, r.finish_odometer, 0) - COALESCE(r.start_odometer,0))::BIGINT end) END)::BIGINT as work_distance')
            ->addSelect('SUM(CASE WHEN r.type=:driving AND r.scope=:private 
            THEN (CASE WHEN ((COALESCE(next_route.next_driving_start_odometer, r.finish_odometer, 0) - COALESCE(r.finish_odometer,0)) > (COALESCE(r.finish_odometer,0) - COALESCE(r.start_odometer,0))
            OR (COALESCE(r.start_odometer, 0) > COALESCE(next_route.next_driving_start_odometer, r.finish_odometer, 0)))
                then (COALESCE(r.finish_odometer, 0) - COALESCE(r.start_odometer,0))::BIGINT
                else (COALESCE(next_route.next_driving_start_odometer, r.finish_odometer, 0) - COALESCE(r.start_odometer,0))::BIGINT end) END)::BIGINT as private_distance')
            ->addSelect('SUM(CASE WHEN r.type=:driving AND r.scope IS NULL
            THEN (CASE WHEN ((COALESCE(next_route.next_driving_start_odometer, r.finish_odometer, 0) - COALESCE(r.finish_odometer,0)) > (COALESCE(r.finish_odometer,0) - COALESCE(r.start_odometer,0))
            OR (COALESCE(r.start_odometer, 0) > COALESCE(next_route.next_driving_start_odometer, r.finish_odometer, 0)))
                then (COALESCE(r.finish_odometer, 0) - COALESCE(r.start_odometer,0))::BIGINT
                else (COALESCE(next_route.next_driving_start_odometer, r.finish_odometer, 0) - COALESCE(r.start_odometer,0))::BIGINT end) END)::BIGINT as unclassified_distance')
            ->addSelect('SUM(CASE WHEN r.type=:driving
            THEN (CASE WHEN ((COALESCE(next_route.next_driving_start_odometer, r.finish_odometer, 0) - COALESCE(r.finish_odometer,0)) > (COALESCE(r.finish_odometer,0) - COALESCE(r.start_odometer,0))
            OR (COALESCE(r.start_odometer, 0) > COALESCE(next_route.next_driving_start_odometer, r.finish_odometer, 0)))
                then (COALESCE(r.finish_odometer, 0) - COALESCE(r.start_odometer,0))::BIGINT
                else (COALESCE(next_route.next_driving_start_odometer, r.finish_odometer, 0) - COALESCE(r.start_odometer,0))::BIGINT end) END)::BIGINT as total_distance')
            ->from($this->getEntityManager()->getClassMetadata(Route::class)->getTableName(), 'r')
            ->innerJoin('r', $vTable, 'v', 'r.vehicle_id = v.id')
            ->leftJoin('r', $driverTable, 'd', 'r.driver_id = d.id')
            ->leftJoin(
                'r',
                sprintf('(%s)', $finishOdometerSubQuery->getSQL()),
                'next_route',
                'next_route.stop_start_point_id = r.point_finish_id'
            )
            ->andWhere(
                $routeQb->expr()->and(
                    $routeQb->expr()->lte('r.started_at', ':dateTo'),
                    $routeQb->expr()->gte('r.finished_at', ':dateFrom')
                )
            )
            ->andWhere('v.team_id IN (:teamIds)')
            ->andWhere('v.status <> :vehicleDeleted')
            ->groupBy('r.vehicle_id');

        if (is_array($params->driverIds)) {
            $routeQb = $routeQb->andWhere('d.id IN (:driverIds)');
        }
        if ($params->vehicleIds) {
            $routeQb = $routeQb->andWhere('v.id IN (:vehicleIds)');
        }

        $q = $connection->createQueryBuilder()
            ->select(
                [
                    'v.id AS id',
                    'NULLIF(v.model, \'\') AS model',
                    'r.driver_name',
                    'v.regno AS reg_no',
                    'v.regno AS regno',
                    'to_char((CASE WHEN r.min_started_at < :dateFrom THEN :dateFrom ELSE r.min_started_at END), \'YYYY-MM-DD"T"HH24:MI:SS"+00:00"\') as started_at',
                    'to_char((CASE WHEN r.max_finished_at > :dateTo THEN :dateTo ELSE r.max_finished_at END), \'YYYY-MM-DD"T"HH24:MI:SS"+00:00"\') as finished_at',
                    'v.defaultlabel',
                    'r.work_distance',
                    'r.work_duration',
                    'ROUND(((r.work_distance::decimal / greatest(r.total_distance::decimal, 1)) * 100 ))::BIGINT as work_percentage',
                    'r.private_distance',
                    'r.private_duration',
                    'ROUND(((r.private_distance::decimal / greatest(r.total_distance::decimal, 1)) * 100 ))::BIGINT as private_percentage',
                    'r.unclassified_distance',
                    'r.unclassified_duration',
                    'ROUND(((r.unclassified_distance::decimal / greatest(r.total_distance::decimal, 1)) * 100 ))::BIGINT as unclassified_percentage',
                    'r.total_distance',
                    'r.total_duration',
                    '(SUM (r.total_distance) OVER ())::BIGINT as all_total_distance',
                    '(SUM (r.total_duration) OVER ())::BIGINT as all_total_duration',
                    '(SUM (r.work_distance) OVER ())::BIGINT as all_total_work_distance',
                    '(SUM (r.work_duration) OVER ())::BIGINT as all_total_work_duration',
                    '(SUM (r.private_distance) OVER ())::BIGINT as all_total_private_distance',
                    '(SUM (r.private_duration) OVER ())::BIGINT as all_total_private_duration',
                    '(SUM (r.unclassified_distance) OVER ())::BIGINT as all_total_unclassified_distance',
                    '(SUM (r.unclassified_duration) OVER ())::BIGINT as all_total_unclassified_duration',
                    'ROUND((((SUM (r.work_distance) OVER ())::decimal / (SUM (r.total_distance) OVER ())::decimal) * 100 ))::BIGINT as all_total_work_percentage',
                    'ROUND((((SUM (r.private_distance) OVER ())::decimal /(SUM (r.total_distance) OVER ())::decimal) * 100 ))::BIGINT as all_total_private_percentage',
                    'ROUND((((SUM (r.unclassified_distance) OVER ())::decimal / (SUM (r.total_distance) OVER ())::decimal) * 100 ))::BIGINT as all_total_unclassified_percentage'
                ]
            )
            ->from($vTable, 'v')
            ->innerJoin('v', sprintf('(%s)', $routeQb->getSQL()), 'r', 'r.vehicle_id = v.id')
            ->orderBy(StringHelper::toSnakeCase($params->sort), $params->order . ' NULLS LAST')
            ->setParameter('dateFrom', $params->startDate)
            ->setParameter('dateTo', $params->endDate)
            ->setParameter('work', Route::SCOPE_WORK, Types::STRING)
            ->setParameter('private', Route::SCOPE_PRIVATE, Types::STRING)
            ->setParameter('driving', Route::TYPE_DRIVING, Types::STRING)
            ->setParameter('vehicleDeleted', Vehicle::STATUS_DELETED)
            ->setParameter('teamIds', $params->teamId, Connection::PARAM_INT_ARRAY);

        if (is_array($params->driverIds)) {
            $q = $q->setParameter('driverIds', $params->driverIds, Connection::PARAM_INT_ARRAY);
        }

        if ($params->vehicleIds) {
            $q = $q->setParameter('vehicleIds', $params->vehicleIds, Connection::PARAM_INT_ARRAY);
        }

        return $q;
    }

    public function getRoutesDriverFbt(FbtDriverReportDTO $params)
    {
        $connection = $this->getEntityManager()->getConnection();
        $driverTable = $this->getEntityManager()->getClassMetadata(User::class)->getTableName();
        $vTable = $this->getEntityManager()->getClassMetadata(Vehicle::class)->getTableName();
        $rTable = $this->getEntityManager()->getClassMetadata(Route::class)->getTableName();

        $finishOdometerSubQuery = $this->getEntityManager()->getConnection()->createQueryBuilder()
            ->select('rs.point_start_id as stop_start_point_id, rr.start_odometer as next_driving_start_odometer')
            ->from($rTable, 'rr')
            ->leftJoin('rr', $rTable, 'rs', 'rr.point_start_id = rs.point_finish_id');

        $routeQb = $connection->createQueryBuilder();
        $routeQb
            ->select(
                [
                    'r.driver_id',
                    'CONCAT(d.name, \' \', d.surname) as driver_name',
                    'string_agg(DISTINCT CASE WHEN v.regno IS NULL THEN null ELSE v.regno END, \', \') as vehicle_regno',
//                    'SUM(CASE WHEN r.type=:driving THEN (COALESCE(next_route.next_driving_start_odometer, r.finish_odometer, 0) - COALESCE(r.start_odometer,0)) END)::BIGINT AS total_distance',
//                    'SUM(CASE WHEN r.type=:driving AND r.scope IS NULL THEN (COALESCE(next_route.next_driving_start_odometer, r.finish_odometer, 0) - COALESCE(r.start_odometer,0)) END)::BIGINT AS unclassified_distance',
                    'SUM(CASE WHEN r.type=:driving THEN EXTRACT(EPOCH FROM (r.finished_at - r.started_at)) END)::BIGINT AS total_duration',
//                    'SUM(CASE WHEN r.type=:driving AND r.scope=:private THEN (COALESCE(next_route.next_driving_start_odometer, r.finish_odometer, 0) - COALESCE(r.start_odometer,0)) END)::BIGINT AS private_distance',
//                    'SUM(CASE WHEN r.type=:driving AND r.scope=:work THEN (COALESCE(next_route.next_driving_start_odometer, r.finish_odometer, 0) - COALESCE(r.start_odometer,0)) END)::BIGINT AS work_distance',
                    'SUM(CASE WHEN r.type=:driving AND r.scope=:work THEN EXTRACT(EPOCH FROM (r.finished_at - r.started_at)) END)::BIGINT AS work_duration',
                    'SUM(CASE WHEN r.type=:driving AND r.scope=:private THEN EXTRACT(EPOCH FROM (r.finished_at - r.started_at)) END)::BIGINT AS private_duration',
                    'SUM(CASE WHEN r.type=:driving AND r.scope IS NULL THEN EXTRACT(EPOCH FROM (r.finished_at - r.started_at)) END)::BIGINT AS unclassified_duration',
                    'MIN(r.started_at) as min_started_at',
                    'MAX(r.finished_at) as max_finished_at',
                    'r.trip_code',
                ]
            )->addSelect('SUM(CASE WHEN r.type=:driving AND r.scope=:work
            THEN (CASE WHEN ((COALESCE(next_route.next_driving_start_odometer, r.finish_odometer, 0) - COALESCE(r.finish_odometer,0)) > (COALESCE(r.finish_odometer,0) - COALESCE(r.start_odometer,0))
            OR (COALESCE(r.start_odometer, 0) > COALESCE(next_route.next_driving_start_odometer, r.finish_odometer, 0)))
                then (COALESCE(r.finish_odometer, 0) - COALESCE(r.start_odometer,0))::BIGINT
                else (COALESCE(next_route.next_driving_start_odometer, r.finish_odometer, 0) - COALESCE(r.start_odometer,0))::BIGINT end) END)::BIGINT as work_distance')
            ->addSelect('SUM(CASE WHEN r.type=:driving AND r.scope=:private 
            THEN (CASE WHEN ((COALESCE(next_route.next_driving_start_odometer, r.finish_odometer, 0) - COALESCE(r.finish_odometer,0)) > (COALESCE(r.finish_odometer,0) - COALESCE(r.start_odometer,0))
            OR (COALESCE(r.start_odometer, 0) > COALESCE(next_route.next_driving_start_odometer, r.finish_odometer, 0)))
                then (COALESCE(r.finish_odometer, 0) - COALESCE(r.start_odometer,0))::BIGINT
                else (COALESCE(next_route.next_driving_start_odometer, r.finish_odometer, 0) - COALESCE(r.start_odometer,0))::BIGINT end) END)::BIGINT as private_distance')
            ->addSelect('SUM(CASE WHEN r.type=:driving AND r.scope IS NULL
            THEN (CASE WHEN ((COALESCE(next_route.next_driving_start_odometer, r.finish_odometer, 0) - COALESCE(r.finish_odometer,0)) > (COALESCE(r.finish_odometer,0) - COALESCE(r.start_odometer,0))
            OR (COALESCE(r.start_odometer, 0) > COALESCE(next_route.next_driving_start_odometer, r.finish_odometer, 0)))
                then (COALESCE(r.finish_odometer, 0) - COALESCE(r.start_odometer,0))::BIGINT
                else (COALESCE(next_route.next_driving_start_odometer, r.finish_odometer, 0) - COALESCE(r.start_odometer,0))::BIGINT end) END)::BIGINT as unclassified_distance')
            ->addSelect('SUM(CASE WHEN r.type=:driving
            THEN (CASE WHEN ((COALESCE(next_route.next_driving_start_odometer, r.finish_odometer, 0) - COALESCE(r.finish_odometer,0)) > (COALESCE(r.finish_odometer,0) - COALESCE(r.start_odometer,0))
            OR (COALESCE(r.start_odometer, 0) > COALESCE(next_route.next_driving_start_odometer, r.finish_odometer, 0)))
                then (COALESCE(r.finish_odometer, 0) - COALESCE(r.start_odometer,0))::BIGINT
                else (COALESCE(next_route.next_driving_start_odometer, r.finish_odometer, 0) - COALESCE(r.start_odometer,0))::BIGINT end) END)::BIGINT as total_distance')
            ->from($this->getEntityManager()->getClassMetadata(Route::class)->getTableName(), 'r')
            ->innerJoin('r', $driverTable, 'd', 'r.driver_id = d.id')
            ->leftJoin('r', $vTable, 'v', 'r.vehicle_id = v.id')
            ->leftJoin(
                'r',
                sprintf('(%s)', $finishOdometerSubQuery->getSQL()),
                'next_route',
                'next_route.stop_start_point_id = r.point_finish_id'
            )
            ->andWhere(
                $routeQb->expr()->and(
                    $routeQb->expr()->lte('r.started_at', ':dateTo'),
                    $routeQb->expr()->gte('r.finished_at', ':dateFrom')
                )
            )
            ->andWhere('d.team_id IN (:teamIds)')
            ->andWhere('d.status <> :driverDeleted')
            ->groupBy('r.driver_id, d.name, d.surname, r.trip_code');

        if ($params->driverIds) {
            $routeQb = $routeQb->andWhere('d.id IN (:driverIds)');
        }
        if ($params->vehicleIds) {
            $routeQb = $routeQb->andWhere('v.id IN (:vehicleIds)');
        }

        $q = $connection->createQueryBuilder()
            ->select(
                [
                    'r.driver_id AS id',
                    'r.driver_name',
                    'r.vehicle_regno as regno',
                    'to_char((CASE WHEN r.min_started_at < :dateFrom THEN :dateFrom ELSE r.min_started_at END), \'YYYY-MM-DD"T"HH24:MI:SS"+00:00"\') as started_at',
                    'to_char((CASE WHEN r.max_finished_at > :dateTo THEN :dateTo ELSE r.max_finished_at END), \'YYYY-MM-DD"T"HH24:MI:SS"+00:00"\') as finished_at',
                    'r.work_distance',
                    'r.work_duration',
                    'ROUND(((r.work_distance::decimal / COALESCE(NULLIF(r.total_distance::decimal,0), 1)) * 100 ))::BIGINT as work_percentage',
                    'r.private_distance',
                    'r.private_duration',
                    'ROUND(((r.private_distance::decimal / COALESCE(NULLIF(r.total_distance::decimal,0), 1)) * 100 ))::BIGINT as private_percentage',
                    'r.unclassified_distance',
                    'r.unclassified_duration',
                    'ROUND(((r.unclassified_distance::decimal / COALESCE(NULLIF(r.total_distance::decimal,0), 1)) * 100 ))::BIGINT as unclassified_percentage',
                    'r.total_distance',
                    'r.total_duration',
                    '(SUM (r.total_distance) OVER ())::BIGINT as all_total_distance',
                    '(SUM (r.total_duration) OVER ())::BIGINT as all_total_duration',
                    '(SUM (r.work_distance) OVER ())::BIGINT as all_total_work_distance',
                    '(SUM (r.work_duration) OVER ())::BIGINT as all_total_work_duration',
                    '(SUM (r.private_distance) OVER ())::BIGINT as all_total_private_distance',
                    '(SUM (r.private_duration) OVER ())::BIGINT as all_total_private_duration',
                    '(SUM (r.unclassified_distance) OVER ())::BIGINT as all_total_unclassified_distance',
                    '(SUM (r.unclassified_duration) OVER ())::BIGINT as all_total_unclassified_duration',
                    'ROUND((((SUM (r.work_distance) OVER ())::decimal / (SUM (r.total_distance) OVER ())::decimal) * 100 ))::BIGINT as all_total_work_percentage',
                    'ROUND((((SUM (r.private_distance) OVER ())::decimal /(SUM (r.total_distance) OVER ())::decimal) * 100 ))::BIGINT as all_total_private_percentage',
                    'ROUND((((SUM (r.unclassified_distance) OVER ())::decimal / (SUM (r.total_distance) OVER ())::decimal) * 100 ))::BIGINT as all_total_unclassified_percentage',
                    'r.trip_code'
                ]
            )
            ->from(sprintf('(%s)', $routeQb->getSQL()), 'r')
            ->orderBy(StringHelper::toSnakeCase($params->sort), $params->order . ' NULLS LAST')
            ->setParameter('dateFrom', $params->startDate)
            ->setParameter('dateTo', $params->endDate)
            ->setParameter('work', Route::SCOPE_WORK, Types::STRING)
            ->setParameter('private', Route::SCOPE_PRIVATE, Types::STRING)
            ->setParameter('driving', Route::TYPE_DRIVING, Types::STRING)
            ->setParameter('driverDeleted', User::STATUS_DELETED)
            ->setParameter('teamIds', $params->teamId, Connection::PARAM_INT_ARRAY);

        if ($params->driverIds) {
            $q = $q->setParameter('driverIds', $params->driverIds, Connection::PARAM_INT_ARRAY);
        }

        if ($params->vehicleIds) {
            $q = $q->setParameter('vehicleIds', $params->vehicleIds, Connection::PARAM_INT_ARRAY);
        }

        return $q;
    }

    /**
     * @param $data
     * @param bool $getVehiclesList
     * @return mixed
     */
    public function getStopsSummary(StopReportDTO $params, $getVehiclesList = false)
    {
        $isNewAreaReport = $params->startDate > Carbon::parse('2024-02-31');

        $em = $this->getEntityManager();
        $qb = $em->createQueryBuilder();

        $asTable = $em->getClassMetadata(RouteStartArea::class)->getTableName();
        $rTable = $em->getClassMetadata(Route::class)->getTableName();
        $aTable = $em->getClassMetadata(Area::class)->getTableName();
        $agTable = $em->getClassMetadata(AreaGroup::class)->getTableName();
        $vgTable = $em->getClassMetadata(VehicleGroup::class)->getTableName();
        $vTable = $em->getClassMetadata(Vehicle::class)->getTableName();
        $depotTable = $em->getClassMetadata(Depot::class)->getTableName();
        $driverTable = $em->getClassMetadata(User::class)->getTableName();

        $groupsSubQuery = $em->getConnection()->createQueryBuilder()
            ->select('string_agg(vg.name, \', \') AS groups, vgs.vehicle_id')
            ->from('vehicles_groups', 'vgs')
            ->leftJoin('vgs', $vgTable, 'vg', 'vg.id =vgs.vehicle_group_id')
            ->groupBy('vgs.vehicle_id');

//        $areaGroupsSubQuery = $em->getConnection()->createQueryBuilder()
//            ->select('string_agg(ag.name, \', \') AS agname, ags.area_id')
//            ->from('areas_groups', 'ags')
//            ->leftJoin('ags', $agTable, 'ag', 'ag.id =ags.area_group_id')
//            ->groupBy('ags.area_id');

//        $areaGroupsSubQuery = $em->getConnection()->createQueryBuilder()
//            ->select('string_agg(ag.name, \', \') AS ag_name, r.id as r_id')
//            ->from($rTable, 'r')
//            ->leftJoin('r', $aTable, 'areas',
//                'ST_Contains(areas.polygon, r.start_coordinates) = true AND areas.status = :areaStatus AND areas.team_id IN (' . implode(', ',
//                    $params->teamId) . ')')
//            ->leftJoin('areas', 'areas_groups', 'ags', 'areas.id = ags.area_id')
//            ->leftJoin('ags', 'area_group', 'ag', 'ags.area_group_id = ag.id')
//            ->andWhere(
//                $qb->expr()->andX(
//                    $qb->expr()->lte('r.started_at', ':dateTo'),
//                    $qb->expr()->gte('r.finished_at', ':dateFrom')
//                )
//            )
//            ->groupBy('r.id');
//
//        if ($params->teamId) {
//            $areaGroupsSubQuery->andWhere('areas.team_id IN (' . implode(', ', $params->teamId) . ')');
//        }

        $query = $this
            ->getEntityManager()
            ->getConnection()
            ->createQueryBuilder()
            ->from($rTable, 'r')
            ->leftJoin('r', $driverTable, 'd', 'r.driver_id = d.id')
            ->leftJoin('r', $vTable, 'v', 'r.vehicle_id = v.id')
            ->leftJoin('v', $depotTable, 'depot', 'v.depot_id = depot.id')
            ->leftJoin(
                'v',
                sprintf('(%s)', $groupsSubQuery->getSQL()),
                'vgs',
                'vgs.vehicle_id = v.id'
            )
//            ->leftJoin('r', sprintf('(%s)', $areaGroupsSubQuery->getSQL()), 'ag', 'r.id = ag.r_id')
            ->leftJoin('areas', 'areas_groups', 'ags', 'areas.id = ags.area_id')
            ->leftJoin('ags', 'area_group', 'ag_', 'ags.area_group_id = ag_.id')
//            ->leftJoin('areas', sprintf('(%s)', $areaGroupsSubQuery->getSQL()), 'ag', 'ag.area_id = areas.id')
            ->andWhere('r.type = :type')
            ->andWhere('v.status <> :vehicleDeleted')
            ->setParameter('vehicleDeleted', Vehicle::STATUS_DELETED)
            ->setParameter('dateFrom', $params->startDate)
            ->setParameter('dateTo', $params->endDate)
            ->setParameter('type', Route::TYPE_STOP)
            ->setParameter('stopped', Route::TYPE_STOP, Types::STRING)
            ->setParameter('areaStatus', Area::STATUS_ACTIVE)
            ->setParameter('typeIdling', RouteTemp::TYPE_IDLING);

        if ($isNewAreaReport) {
            $query->leftJoin('r', $asTable, 'route_start_area', 'route_start_area.route_id = r.id')
                ->leftJoin('r', $aTable, 'areas', 'areas.id = route_start_area.area_id');
        } else {
            $query->leftJoin('r', $aTable, 'areas',
                'ST_Contains(areas.polygon, r.start_coordinates) = true AND areas.status = :areaStatus AND areas.team_id IN (' . implode(', ',
                    $params->teamId) . ')');
        }

        if ($getVehiclesList) {
            $query->select('v.id')
                ->addSelect('SUM(extract(epoch from (r.finished_at::timestamp - r.started_at::timestamp))) as parking_time')
                ->groupBy('v.id');
        } else {
            $query->select('v.defaultLabel, v.regNo, v.model')
                ->addSelect('(CASE WHEN d.name IS NULL THEN null ELSE CONCAT(d.name, \' \', d.surname) END) as driver_name')
                ->addSelect('vgs.groups')
                ->addSelect('depot.name as depot_name, depot.id as depotId')
                ->addSelect(
                    'r.id as route_id, to_char (r.started_at, \'YYYY-MM-DD"T"HH24:MI:SS"+00:00"\') as started_at'
                )
                ->addSelect('to_char (r.finished_at, \'YYYY-MM-DD"T"HH24:MI:SS"+00:00"\') as finished_at')
                ->addSelect('r.address')
                ->addSelect('string_agg(DISTINCT areas.name, \', \') as areas_name')
                ->addSelect('string_agg(DISTINCT ag_.name, \', \') AS areas_group_name')
//                ->addSelect('ag.ag_name as areas_group_name')
                ->addSelect('r.finish_odometer')
                ->addSelect('extract(epoch from (r.finished_at::timestamp - r.started_at::timestamp)) as parking_time')
                ->addSelect('r.total_idle_duration as idling_time')
                ->addSelect(
                    '(SUM (extract(epoch from (r.finished_at::timestamp - r.started_at::timestamp))) OVER ()) as parking_time_total'
                )
                ->groupBy('v.regNo, v.defaultLabel, v.model, driver_name, vgs.groups, depotId, r.id')
                ->orderBy($params->sort, $params->order . ' NULLS LAST');
        }

        $query->andWhere(
            $qb->expr()->andX(
                $qb->expr()->lte('r.started_at', ':dateTo'),
                $qb->expr()->gte('r.finished_at', ':dateFrom')
            )
        );

        if ($params->defaultLabel) {
            if (is_array($params->defaultLabel)) {
                $q = [];
                foreach ($params->defaultLabel as $index => $label) {
                    $q[] = $qb->expr()->like('LOWER(v.defaultLabel)', ":label$index");
                    $query->setParameter("label$index", strtolower($label) . '%');
                }
                $query->andWhere(new Orx($q));
            } else {
                $query->andWhere('LOWER(v.defaultLabel) LIKE LOWER(:defaultLabel)')
                    ->setParameter('defaultLabel', $params->defaultLabel . '%');
            }
        }

        if ($params->vehicleRegNo) {
            $query->andWhere('LOWER(v.regNo) LIKE LOWER(:regNo)')
                ->setParameter('regNo', $params->vehicleRegNo . '%');
        }

        if ($params->driver) {
            $query->andWhere('LOWER(CONCAT(d.name, \' \', d.surname)) LIKE LOWER(:driverName)')
                ->setParameter('driverName', $params->driver . '%');
        }

        if ($params->driverId) {
            $query->andWhere('d.id IN (:driverId)')
                ->setParameter('driverId', $params->driverId, Connection::PARAM_INT_ARRAY);
        }

        if ($params->vehicleDepot) {
            $query->andWhere('depot_id = :depotId')
                ->setParameter('depotId', $params->vehicleDepot);
        }

        if ($params->vehicleId) {
            $query->andWhere('r.vehicle_id = :vehicleId')
                ->setParameter('vehicleId', $params->vehicleId);
        }

        if ($params->vehicleIds) {
            $query->andWhere('r.vehicle_id IN (' . implode(', ', $params->vehicleIds) . ')');
        }

        $query = $this->addAreaGroupsFilter($query, $params->areaGroup, $params->noAreaGroup, 'ag_', 'ag');
        $query = $this->addDepotIdFilter($query, $params->depotId, $params->noDepot);
        $query = $this->addGroupsFilter($query, $params->vehicleGroup, $params->noGroups);

        $query = $this->addAreaFilter($query, $params->area, $params->noArea, 'areas');

        if ($params->teamId) {
            $query->andWhere('v.team_id IN (' . implode(', ', $params->teamId) . ')')
                ->setParameter('teamId', $params->teamId);
        }

        return $query;
    }

    /**
     * @param $data
     * @return mixed
     */
    public function getDriverSummary($data)
    {
        $em = $this->getEntityManager();
        $qb = $this->getQB();
        $dateFrom = $data['startDate'];
        $dateTo = $data['endDate'];

        $vehicleDefaultLabel = $data['vehicleDefaultLabel'];
        $vehicleRegNo = $data['vehicleRegNo'];
        $driverName = $data['driver'];
        $vehicleId = $data['vehicleId'];
        $vehicleIds = $data['vehicleIds'];
        $driverId = $data['driverId'];
        $teamId = $data['teamId'];
        $order = $data['order'];
        $sort = $data['sort'];

        $rTable = $em->getClassMetadata(Route::class)->getTableName();
        $vTable = $em->getClassMetadata(Vehicle::class)->getTableName();
        $driverTable = $em->getClassMetadata(User::class)->getTableName();
        $speedingTable = $em->getClassMetadata(Speeding::class)->getTableName();
        $driverBehaviorTable = $em->getClassMetadata(DrivingBehavior::class)->getTableName();

        $driverBehaviorQuery = $em->getConnection()->createQueryBuilder()
            ->select(
                '(COALESCE(SUM(db.harsh_acceleration),0) + COALESCE(SUM(db.harsh_braking),0) + COALESCE(SUM(db.harsh_cornering),0)) as db_count'
            )
            ->addSelect('db.vehicle_id')
            ->from($driverBehaviorTable, 'db')
            ->leftJoin('db', $vTable, 'v', 'db.vehicle_id = v.id')
            ->andWhere($this->getQB()->expr()->between('db.ts', ':dateFrom', ':dateTo'))
            ->andWhere('v.team_id IN (:teamIds)')
            ->groupBy('db.vehicle_id');

        $workQuery = $em->getConnection()->createQueryBuilder()
            ->select('SUM(r.distance) as distance, r.vehicle_id')
            ->addSelect('SUM (extract(epoch from (r.finished_at::timestamp - r.started_at::timestamp))) as duration')
            ->from($rTable, 'r')
            ->leftJoin('r', $vTable, 'v', 'r.vehicle_id = v.id')
            ->andWhere('r.scope = :work')
            ->andWhere('r.type = :driving')
            ->andWhere('v.team_id IN (:teamIds)')
            ->groupBy('r.vehicle_id');

        $privateQuery = $em->getConnection()->createQueryBuilder()
            ->select('SUM(r.distance) as distance, r.vehicle_id')
            ->addSelect('SUM (extract(epoch from (r.finished_at::timestamp - r.started_at::timestamp))) as duration')
            ->from($rTable, 'r')
            ->leftJoin('r', $vTable, 'v', 'r.vehicle_id = v.id')
            ->andWhere('r.scope = :private')
            ->andWhere('r.type = :driving')
            ->andWhere('v.team_id IN (:teamIds)')
            ->groupBy('r.vehicle_id');

        $stopsQuery = $em->getConnection()->createQueryBuilder()
            ->select('COUNT(r) as stops_count, r.vehicle_id')
            ->addSelect(
                'SUM (extract(epoch from (r.finished_at::timestamp - r.started_at::timestamp))) as parking_time'
            )
            ->from($rTable, 'r')
            ->leftJoin('r', $vTable, 'v', 'r.vehicle_id = v.id')
            ->andWhere('r.type = :stopped')
            ->andWhere('v.team_id IN (:teamIds)')
            ->groupBy('r.vehicle_id');

        $speedingQuery = $em->getConnection()->createQueryBuilder()
            ->select('COUNT(s) as speeding_events_count, s.vehicle_id')
            ->from($speedingTable, 's')
            ->leftJoin('s', $vTable, 'v', 's.vehicle_id = v.id')
            ->andWhere('v.team_id IN (:teamIds)')
            ->groupBy('s.vehicle_id');

        $workQuery = $this->addDateFilter($workQuery, $qb);
        $privateQuery = $this->addDateFilter($privateQuery, $qb);
        $stopsQuery = $this->addDateFilter($stopsQuery, $qb);
        $speedingQuery = $this->addDateFilter($speedingQuery, $qb, 's');

        $query = $this
            ->getEntityManager()
            ->getConnection()
            ->createQueryBuilder()
            ->from($rTable, 'r')
            ->leftJoin('r', $driverTable, 'd', 'r.driver_id = d.id')
            ->leftJoin('r', $vTable, 'v', 'r.vehicle_id = v.id')
            ->andWhere('r.driver_id IS NOT NULL')
            ->andWhere('r.type = :driving')
            ->setParameter('dateFrom', $dateFrom)
            ->setParameter('dateTo', $dateTo)
            ->setParameter('type', Route::TYPE_DRIVING)
            ->setParameter('driving', Route::TYPE_DRIVING)
            ->setParameter('stopped', Route::TYPE_STOP, Types::STRING)
            ->setParameter('areaStatus', Area::STATUS_ACTIVE)
            ->setParameter('work', Route::SCOPE_WORK, Types::STRING)
            ->setParameter('private', Route::SCOPE_PRIVATE, Types::STRING);

        if ($driverId) {
            if (is_array($driverId)) {
                $query->andWhere('r.driver_id IN (:driverId)')
                    ->setParameter('driverId', $driverId, ArrayParameterType::INTEGER);
            } else {
                $query->andWhere('r.driver_id = :driverId')->setParameter('driverId', $driverId);
            }

            $driverBehaviorQuery = $this->addDriverIdFilter($driverBehaviorQuery, $driverId, 'db');
            $workQuery = $this->addDriverIdFilter($workQuery, $driverId);
            $privateQuery = $this->addDriverIdFilter($privateQuery, $driverId);
            $stopsQuery = $this->addDriverIdFilter($stopsQuery, $driverId);
            $speedingQuery = $this->addDriverIdFilter($speedingQuery, $driverId, 's');
        }

        $query->leftJoin(
            'r',
            sprintf('(%s)', $workQuery->getSQL()),
            'work',
            'r.vehicle_id = work.vehicle_id'
        );

        $query->leftJoin(
            'r',
            sprintf('(%s)', $driverBehaviorQuery->getSQL()),
            'db',
            'r.vehicle_id = db.vehicle_id'
        );

        $query->leftJoin(
            'r',
            sprintf('(%s)', $privateQuery->getSQL()),
            'private',
            'r.vehicle_id = private.vehicle_id'
        );

        $query->leftJoin(
            'r',
            sprintf('(%s)', $stopsQuery->getSQL()),
            'stops',
            'r.vehicle_id = stops.vehicle_id'
        );

        $query->leftJoin(
            'r',
            sprintf('(%s)', $speedingQuery->getSQL()),
            'speeding',
            'r.vehicle_id = speeding.vehicle_id'
        );

        $query->addSelect(
            [
                'DISTINCT ON(regno) regno',
                'CONCAT(v.regno, \' \', v.defaultlabel) as used_vehicles',
                'MAX(work.distance::BIGINT) as work_distance',
                'MAX(work.duration::BIGINT) as work_duration',
                'MAX(private.distance::BIGINT) as private_distance',
                'MAX(private.duration::BIGINT) as private_duration',
                'SUM(r.distance)::BIGINT as total_distance',
                'SUM (extract(epoch from (r.finished_at::timestamp - r.started_at::timestamp)))::BIGINT as total_duration',
                'MAX(r.max_speed) as max_speed',
                'MAX(stops_count::BIGINT) as stops_count',
                'MAX(stops.parking_time::BIGINT) as parking_time',
                'MAX(speeding.speeding_events_count::BIGINT) as speeding_events_count',
                'db_count::BIGINT as eco_drive_events',
                'calc_event_score((COALESCE(SUM(r.distance), 0)), db_count) as eco_drive_score',
                'v.defaultlabel',
                'r.driver_id',
                'r.vehicle_id'
            ]
        )
            ->orderBy($sort, $order)
            ->orderBy('regno', $order)
            ->groupBy('r.vehicle_id, v.regno, v.defaultlabel,r.driver_id, db_count');

        $query = $this->addDateFilter($query, $qb);

        if ($vehicleDefaultLabel) {
            $query->andWhere('LOWER(v.defaultLabel) LIKE LOWER(:defaultLabel)')
                ->setParameter('defaultLabel', $vehicleDefaultLabel . '%');
        }

        if ($vehicleRegNo) {
            $query->andWhere('LOWER(v.regNo) LIKE LOWER(:regNo)')
                ->setParameter('regNo', $vehicleRegNo . '%');
        }

        if ($driverName) {
            $query->andWhere('LOWER(CONCAT(d.name, \' \', d.surname)) LIKE LOWER(:driverName)')
                ->setParameter('driverName', $driverName . '%');
        }

        if ($vehicleId) {
            $query->andWhere('r.vehicle_id = :vehicleId')
                ->setParameter('vehicleId', $vehicleId);
        }

        if ($vehicleIds) {
            $query->andWhere('r.vehicle_id IN (:vehicleIds)')
                ->setParameter('vehicleIds', $vehicleIds, Connection::PARAM_INT_ARRAY);
        }

        if ($teamId) {
            $query
                ->andWhere('v.team_id IN (:teamIds)')
                ->andWhere('d.team_id IN (:teamIds)')
                ->setParameter('teamIds', $teamId, Connection::PARAM_INT_ARRAY);
        }

        $query2 = $this
            ->getEntityManager()
            ->getConnection()
            ->createQueryBuilder()
            ->from($vTable, 'v')
            ->rightJoin(
                'v',
                sprintf('(%s)', $query->getSQL()),
                'rr',
                'rr.vehicle_id = v.id'
            )
            ->setParameter('dateFrom', $dateFrom)
            ->setParameter('dateTo', $dateTo)
            ->setParameter('type', Route::TYPE_DRIVING)
            ->setParameter('driving', Route::TYPE_DRIVING)
            ->setParameter('stopped', Route::TYPE_STOP, Types::STRING)
            ->setParameter('areaStatus', Area::STATUS_ACTIVE)
            ->setParameter('work', Route::SCOPE_WORK, Types::STRING)
            ->setParameter('private', Route::SCOPE_PRIVATE, Types::STRING)
            ->setParameter('driverId', $driverId);

        $query2->addSelect(
            [
                'SUM(rr.eco_drive_events) as eco_drive_events_total',
                'rr.driver_id',
                'MAX(rr.max_speed) as max_speed_total',
                'SUM(rr.stops_count) as stops_count_total',
                'SUM(rr.speeding_events_count) as speeding_events_count_total',
                'SUM(rr.work_distance) as work_distance_total',
                'SUM(rr.work_duration) as work_duration_total',
                'SUM(rr.private_distance) as private_distance_total',
                'SUM(rr.private_duration) as private_duration_total',
                'SUM(rr.total_distance) as total_distance_total',
                'SUM(rr.total_duration) as total_duration_total',
                'SUM(rr.parking_time) as parking_time_total',
            ]
        )->groupBy('rr.driver_id');

        $query->leftJoin(
            'r',
            sprintf('(%s)', $query2->getSQL()),
            'rg',
            'rg.driver_id = r.driver_id'
        );

        $query->addSelect(
            [
                'MAX(eco_drive_events_total) as eco_drive_events_total',
                'round(calc_event_score(COALESCE(MAX(total_distance_total), 0), COALESCE(MAX(eco_drive_events_total), 0))) as eco_drive_score_total',
                'MAX(max_speed_total) as max_speed_total',
                'MAX(stops_count_total) as stops_count_total',
                'MAX(speeding_events_count_total) as speeding_events_count_total',
                'MAX(work_distance_total) as work_distance_total',
                'MAX(work_duration_total) as work_duration_total',
                'MAX(private_distance_total) as private_distance_total',
                'MAX(private_duration_total) as private_duration_total',
                'MAX(total_distance_total::BIGINT) as total_distance_total',
                'MAX(total_duration_total) as total_duration_total',
                'MAX(parking_time_total) as parking_time_total'
            ]
        );

        return $query;
    }

    /**
     * @param $data
     * @return \Doctrine\DBAL\Query\QueryBuilder|mixed
     */
    public function getDriverListSummary($data)
    {
        $em = $this->getEntityManager();
        $qb = $this->getQB();
        $dateFrom = $data['startDate'];
        $dateTo = $data['endDate'];

        $vehicleDefaultLabel = $data['vehicleDefaultLabel'];
        $vehicleRegNo = $data['vehicleRegNo'];
        $vehicleIds = $data['vehicleIds'];
        $driverName = $data['driver'];
        $teamId = $data['teamId'];

        $rTable = $em->getClassMetadata(Route::class)->getTableName();
        $vTable = $em->getClassMetadata(Vehicle::class)->getTableName();
        $driverTable = $em->getClassMetadata(User::class)->getTableName();

        $query = $this
            ->getEntityManager()
            ->getConnection()
            ->createQueryBuilder()
            ->from($rTable, 'r')
            ->leftJoin('r', $driverTable, 'd', 'r.driver_id = d.id')
            ->leftJoin('r', $vTable, 'v', 'r.vehicle_id = v.id')
            ->where('r.type = :type')
            ->andWhere('r.driver_id IS NOT NULL')
            ->setParameter('dateFrom', $dateFrom)
            ->setParameter('dateTo', $dateTo)
            ->setParameter('type', Route::TYPE_DRIVING);

        $query->addSelect('r.driver_id')
            ->addSelect('d.name')
            ->addSelect('d.surname')
            ->addSelect('CONCAT(d.name, \' \', d.surname) as driver_name')
            ->groupBy('r.driver_id, driver_name, d.name, d.surname');


        $query = $this->addDateFilter($query, $qb);

        if ($vehicleDefaultLabel) {
            $query->andWhere('LOWER(v.defaultLabel) LIKE LOWER(:defaultLabel)')
                ->setParameter('defaultLabel', $vehicleDefaultLabel . '%');
        }

        if ($vehicleRegNo) {
            $query->andWhere('LOWER(v.regNo) LIKE LOWER(:regNo)')
                ->setParameter('regNo', $vehicleRegNo . '%');
        }

        if ($vehicleIds) {
            $query->andWhere('r.vehicle_id IN (' . implode(', ', $vehicleIds) . ')');
        }

        if ($driverName) {
            $query->andWhere('LOWER(CONCAT(d.name, \' \', d.surname)) LIKE LOWER(:driverName)')
                ->setParameter('driverName', $driverName . '%');
        }

        if ($data['driverId'] ?? null) {
            $query->andWhere('d.id IN (:driverId)')
                ->setParameter('driverId', $data['driverId'], Connection::PARAM_INT_ARRAY);
        }

        if ($teamId) {
            $query
                ->andWhere('v.team_id IN (:teamIds)')
                ->andWhere('d.team_id IN (:teamIds)')
                ->setParameter('teamIds', $teamId, Connection::PARAM_INT_ARRAY);
        }

        return $query;
    }

    /**
     * @param $query
     * @param $qb
     * @return mixed
     */
    public function addDateFilter($query, $qb, $table = 'r')
    {
        return $query->andWhere(
            $qb->expr()->andX(
                $qb->expr()->lte($table . '.started_at', ':dateTo'),
                $qb->expr()->gte($table . '.finished_at', ':dateFrom')
            )
        );
    }

    /**
     * @return \Doctrine\ORM\QueryBuilder
     */
    public function getQB()
    {
        return $this->getEntityManager()->createQueryBuilder();
    }

    /**
     * @param $query
     * @param $driverId
     * @return mixed
     */
    public function addDriverIdFilter($query, $driverId, $table = 'r')
    {
        if (is_array($driverId)) {
            return $query->andWhere($table . '.driver_id IN (:driverId)')
                ->setParameter('driverId', $driverId, ArrayParameterType::INTEGER);
        } else {
            return $query->andWhere($table . '.driver_id = :driverId')->setParameter('driverId', $driverId);
        }
    }

    /**
     * @param Vehicle $vehicle
     * @param \DateTime $startedAt
     *
     * @return Query
     */
    public function getRoutesByVehicleAndStartedDateQb(Vehicle $vehicle, \DateTime $startedAt): Query
    {
        $qb = $this->getEntityManager()
            ->createQueryBuilder();

        return $qb->select('r')
            ->from(Route::class, 'r')
            ->where($qb->expr()->eq('IDENTITY(r.vehicle)', ':vehicle'))
            ->andWhere($qb->expr()->gte('r.startedAt', ':startedAt'))
            ->setParameter('vehicle', $vehicle)
            ->setParameter('startedAt', $startedAt)
            ->getQuery();
    }

    /**
     * @param Device $device
     * @param $dateFrom
     * @param $dateTo
     * @param $duration
     * @param $distance
     * @param $type
     * @param bool $isDriverNull
     * @param bool $isVehicleNotNull
     * @return array|null
     */
    public function getRoutesByDateRangeAndDevice(
        Device $device,
        $dateFrom,
        $dateTo,
        $duration = null,
        $type = null,
        $distance = null,
        $isDriverNull = false,
        $isVehicleNotNull = true
    ): ?array {
        $qb = $this->getEntityManager()
            ->createQueryBuilder();

        $q = $this->getEntityManager()
            ->createQueryBuilder()
            ->select('r')
            ->from(Route::class, 'r')
            ->where('r.device = :device')
            ->andWhere(
                $qb->expr()->andX(
                    $qb->expr()->lte('r.startedAt', ':dateTo'),
                    $qb->expr()->gte('r.finishedAt', ':dateFrom')
                )
            )
            ->orderBy('r.startedAt')
            ->setParameter('device', $device)
            ->setParameter('dateFrom', $dateFrom)
            ->setParameter('dateTo', $dateTo);

        if ($duration) {
            $q->andWhere('extract(epoch from (r.finishedAt - r.startedAt)) > :duration')
                ->setParameter('duration', $duration);
        }

        if ($distance) {
            $q->andWhere('r.distance > :distance')
                ->setParameter('distance', $distance);
        }

        if ($type) {
            $q->andWhere('r.type = :type')->setParameter('type', $type);
        };

        if ($isDriverNull) {
            $q->andWhere('r.driver IS NULL');
        }

        if ($isVehicleNotNull) {
            $q->andWhere('r.vehicle IS NOT NULL');
        }

        return $q->getQuery()->getResult();
    }

    /**
     * @param null $startDate
     * @return \Doctrine\DBAL\Driver\ResultStatement
     * @throws \Doctrine\DBAL\Exception
     */
    public function removeRouteDuplicates($startDate = null, $finishDate = null)
    {
        $startDate = $startDate ?: Carbon::now()->subMonth();
        $finishDate = $finishDate ?: Carbon::now();
        $sql = sprintf('DELETE FROM route r
            WHERE r.id IN
              (SELECT id FROM
                   (SELECT id, ROW_NUMBER() OVER (PARTITION BY started_at, device_id ORDER BY finished_at DESC) AS row_num
                    FROM route WHERE started_at >= \'%s\' AND finished_at <= \'%s\') r_sub
               WHERE r_sub.row_num > 1)', $startDate, $finishDate);

        return $this->getEntityManager()->getConnection()->executeQuery($sql);
    }

    /**
     * @param int $deviceId
     * @return \Doctrine\DBAL\Driver\ResultStatement
     * @throws \Doctrine\DBAL\DBALException
     */
    public function removeRouteDuplicatesByDeviceId(int $deviceId)
    {
        $sql = 'DELETE FROM route r
            WHERE r.id IN
              (SELECT id FROM
                   (SELECT id, ROW_NUMBER() OVER (PARTITION BY started_at ORDER BY finished_at DESC) AS row_num
                    FROM route WHERE device_id = ?) r_sub
               WHERE r_sub.row_num > 1)';

        return $this->getEntityManager()->getConnection()->executeQuery($sql, [$deviceId]);
    }

    /**
     * @param array $deviceIds
     * @param int|null $limit
     * @return mixed[]
     * @throws \Doctrine\DBAL\DBALException
     */
    public function getRoutesWithWrongPoints(array $deviceIds, ?int $limit = 50)
    {
        $allowedMinDT = (new Carbon())->subDays(UpdateWrongRoutesCommand::WRONG_ROUTES_START_DAY_OFFSET);
        $allowedMaxDT = (new Carbon())->subDays(UpdateWrongRoutesCommand::WRONG_ROUTES_FINISH_DAY_OFFSET);
        $sql = 'SELECT r1.id,
               r1.started_at,
               r1.finished_at,
               r1.device_id,
               (SELECT r.started_at AS route_prev_started_at
                FROM route r
                WHERE r.device_id = r1.device_id AND r.started_at < r1.started_at
                ORDER BY r.started_at DESC LIMIT 1),
               (SELECT r.finished_at AS route_next_finished_at
                FROM route r
                WHERE r.device_id = r1.device_id AND r.finished_at > r1.finished_at
                ORDER BY r.finished_at LIMIT 1)
            FROM route r1
                     LEFT JOIN route r_finish_miss ON r_finish_miss.point_finish_id = r1.point_start_id
                     LEFT JOIN route r_start_miss ON r_start_miss.point_start_id = r1.point_finish_id
                     LEFT JOIN (SELECT MAX(r.started_at) AS max_started_at, MIN(r.started_at) AS min_started_at, r.device_id
                                FROM route r
                                GROUP BY r.device_id) r_max_min ON r_max_min.device_id = r1.device_id
            WHERE r1.device_id IN (?)
              AND r1.finished_at IS NOT NULL
              AND (r_finish_miss IS NULL OR r_start_miss IS NULL)
              AND (r_max_min.max_started_at <> r1.started_at)
              AND (r_max_min.min_started_at <> r1.started_at)
              AND r1.started_at > ?
              AND r1.started_at < ?
            ORDER BY r1.started_at DESC
            LIMIT ?
        ';

        return $this->getEntityManager()->getConnection()
            ->executeQuery($sql, [$deviceIds, $allowedMinDT, $allowedMaxDT, $limit], [Connection::PARAM_INT_ARRAY])
            ->fetchAll();
    }

    /**
     * @param $id
     * @param User $currentUser
     * @return mixed
     * @throws \Doctrine\ORM\NonUniqueResultException
     */
    public function getRouteById($id, User $currentUser)
    {
        $qb = $this->getEntityManager()
            ->createQueryBuilder()
            ->select('r')
            ->from(Route::class, 'r')
            ->andWhere('r.id = :id')
            ->setParameter('id', $id);

        if ($currentUser->needToCheckUserGroup()) {
            $userVehicles = $this->getEntityManager()->getRepository(UserGroup::class)
                ->getUserVehiclesIdFromUserGroup($currentUser);
            $qb->andWhere('IDENTITY(r.vehicle) in (:vehicleIds)')->setParameter('vehicleIds', $userVehicles);
        }

        return $qb->getQuery()->getOneOrNullResult();
    }

    public function getRoutesByTimeAgoWithoutLocation($dateTo): Query
    {
        return $this->getEntityManager()
            ->createQueryBuilder()
            ->select('r')
            ->from(Route::class, 'r')
            ->andWhere('r.createdAt < :dateTo')
            ->andWhere('r.isLocationChecked = false')
            ->andWhere('r.address IS NULL')
            ->andWhere('r.type = :stopType')
            ->setParameter('dateTo', $dateTo)
            ->setParameter('stopType', Route::TYPE_STOP)
            ->getQuery();
    }

    /**
     * @param string $createdAtFrom
     * @param string $createdAtTo
     * @param string $startedAtFrom
     * @param string $startedAtTo
     * @param int $speedDiff
     * @return Query
     */
    public function getRoutesWithWrongSpeedStatsQuery(
        ?string $createdAtFrom,
        ?string $createdAtTo,
        ?string $startedAtFrom,
        ?string $startedAtTo,
        int $speedDiff = 0
    ): Query {
        $query = $this->getEntityManager()
            ->createQueryBuilder()
            ->select('r')
            ->from(Route::class, 'r')
            ->where('r.type = :type')
            ->andWhere('r.maxSpeed <> 0')
            ->andWhere('r.maxSpeed - r.avgSpeed <= :speedDiff')
            ->setParameter('startedAtTo', $startedAtTo)
            ->setParameter('speedDiff', $speedDiff)
            ->setParameter('type', Route::TYPE_DRIVING);

        if ($createdAtFrom) {
            $query->andWhere('r.createdAt > :createdAtFrom')
                ->setParameter('createdAtFrom', $createdAtFrom);
        }

        if ($createdAtTo) {
            $query->andWhere('r.createdAt < :createdAtTo')
                ->setParameter('createdAtTo', $createdAtTo);
        }

        if ($startedAtFrom) {
            $query->andWhere('r.startedAt > :startedAtFrom')
                ->setParameter('startedAtFrom', $startedAtFrom);
        }

        if ($startedAtTo) {
            $query->andWhere('r.startedAt < :startedAtTo')
                ->setParameter('startedAtTo', $startedAtTo);
        }

        return $query->getQuery();
    }

    /**
     * @param int $deviceId
     * @param string|null $createdAtFrom
     * @param string|null $createdAtTo
     * @param string|null $startedAtFrom
     * @param string|null $startedAtTo
     * @return Query
     */
    public function getRoutesForPostponedDataQuery(
        int $deviceId,
        ?string $createdAtFrom,
        ?string $createdAtTo,
        ?string $startedAtFrom,
        ?string $startedAtTo
    ): Query {
        $query = $this->getEntityManager()
            ->createQueryBuilder()
            ->select('r')
            ->from(Route::class, 'r')
            ->where('IDENTITY(r.device) = :deviceId')
            ->setParameter('deviceId', $deviceId);

        if ($createdAtFrom) {
            $query->andWhere('r.createdAt >= :createdAtFrom')
                ->setParameter('createdAtFrom', $createdAtFrom);
        }

        if ($createdAtTo) {
            $query->andWhere('r.createdAt <= :createdAtTo')
                ->setParameter('createdAtTo', $createdAtTo);
        }

        if ($startedAtFrom) {
            $query->andWhere('r.startedAt >= :startedAtFrom')
                ->setParameter('startedAtFrom', $startedAtFrom);
        }

        if ($startedAtTo) {
            $query->andWhere('r.startedAt <= :startedAtTo')
                ->setParameter('startedAtTo', $startedAtTo);
        }

        return $query->getQuery();
    }

    public function getPartialRouteByVehicle(Vehicle $vehicle, string $date): ?Route
    {
        $qb = $this->getEntityManager()->createQueryBuilder();

        $qb->select('r')->from(Route::class, 'r')
            ->andWhere('r.vehicle = :vehicle')
            ->andWhere(
                $qb->expr()->between(':date', 'r.startedAt', 'r.finishedAt')
            )
            ->setParameter('vehicle', $vehicle)
            ->setParameter('date', $date)
            ->setMaxResults(1);

        return $qb->getQuery()->getOneOrNullResult();
    }

    /**
     * @param string $tsFrom
     * @param int $deviceId
     * @return mixed
     * @throws \Doctrine\ORM\NonUniqueResultException
     */
    public function getStartedAtByDeviceIdAndTs(int $deviceId, ?string $tsFrom)
    {
        if (!$tsFrom) {
            return null;
        }

        $result = $this->getEntityManager()
            ->createQueryBuilder()
            ->select('r.startedAt')
            ->from(Route::class, 'r')
            ->where('IDENTITY(r.device) = :deviceId')
            ->andWhere('r.finishedAt = :tsFrom')
            ->andWhere('r.startedAt IS NOT NULL')
            ->setParameter('deviceId', $deviceId)
            ->setParameter('tsFrom', $tsFrom)
            ->getQuery()
            ->setMaxResults(1)
            ->getOneOrNullResult();

        return $result ? $result['startedAt']->format(DateHelper::FORMAT_DATE_STRING) : null;
    }

    /**
     * @param string $tsTo
     * @param int $deviceId
     * @return mixed
     * @throws \Doctrine\ORM\NonUniqueResultException
     */
    public function getFinishedAtByDeviceIdAndTs(int $deviceId, ?string $tsTo)
    {
        if (!$tsTo) {
            return null;
        }

        $result = $this->getEntityManager()
            ->createQueryBuilder()
            ->select('r.finishedAt')
            ->from(Route::class, 'r')
            ->where('IDENTITY(r.device) = :deviceId')
            ->andWhere('r.startedAt = :tsTo')
            ->andWhere('r.finishedAt IS NOT NULL')
            ->setParameter('deviceId', $deviceId)
            ->setParameter('tsTo', $tsTo)
            ->getQuery()
            ->setMaxResults(1)
            ->getOneOrNullResult();

        return $result ? $result['finishedAt']->format(DateHelper::FORMAT_DATE_STRING) : null;
    }

    /**
     * @param Device $device
     * @param Vehicle $vehicle
     * @param int $odometer
     * @param \DateTimeInterface|string|null $dateFrom
     * @param \DateTimeInterface|string|null $dateTo
     * @return mixed
     */
    public function updateRoutesDistanceAndOdometer(
        Device $device,
        ?Vehicle $vehicle,
        int $odometer,
        $dateFrom = null,
        $dateTo = null
    ) {
        $query = $this->getEntityManager()
            ->createQueryBuilder()
            ->update(Route::class, 'r')
            ->set('r.startOdometer', $odometer)
            ->set('r.finishOdometer', $odometer)
            ->set('r.distance', 0)
            ->where('r.device = :device')
            ->setParameter('device', $device);

        if ($vehicle) {
            $query->andWhere('r.vehicle = :vehicle')
                ->setParameter('vehicle', $vehicle);
        }
        if ($dateFrom) {
            $query->andWhere('r.startedAt >= :dateFrom')
                ->setParameter('dateFrom', $dateFrom);
        }
        if ($dateTo) {
            $query->andWhere('r.startedAt <= :dateTo')
                ->setParameter('dateTo', $dateTo);
        }

        return $query->getQuery()->execute();
    }

    /**
     * @param int $thId
     * @param int $odometer
     * @return mixed
     */
    public function updateStartOdometerByTrackerHistoryId(
        int $thId,
        int $odometer
    ) {
        $query = $this->getEntityManager()
            ->createQueryBuilder()
            ->update(Route::class, 'r')
            ->set('r.startOdometer', $odometer)
            ->where('IDENTITY(r.pointStart) = :thId')
            ->setParameter('thId', $thId);

        return $query->getQuery()->execute();
    }

    /**
     * @param int $thId
     * @param int $odometer
     * @return mixed
     */
    public function updateFinishOdometerByTrackerHistoryId(
        int $thId,
        int $odometer
    ) {
        $query = $this->getEntityManager()
            ->createQueryBuilder()
            ->update(Route::class, 'r')
            ->set('r.finishOdometer', $odometer)
            ->where('IDENTITY(r.pointFinish) = :thId')
            ->setParameter('thId', $thId);

        return $query->getQuery()->execute();
    }

    /**
     * @param int $thId
     * @return mixed
     */
    public function updateDistanceByTrackerHistoryId(
        int $thId
    ) {
        $query = $this->getEntityManager()
            ->createQueryBuilder()
            ->update(Route::class, 'r')
            ->set('r.distance', 'r.finishOdometer - r.startOdometer')
            ->where('IDENTITY(r.pointFinish) = :thId')
            ->orWhere('IDENTITY(r.pointStart) = :thId')
            ->setParameter('thId', $thId);

        return $query->getQuery()->execute();
    }

    public function getRoutesByDriverAndRange(User $driver, $dateFrom, $dateTo)
    {
        $qb = $this->getEntityManager()->createQueryBuilder();

        return $this->getEntityManager()
            ->createQueryBuilder()
            ->select('r.scope, r.distance')
            ->addSelect('v.regNo as regno')
            ->from(Route::class, 'r')
            ->leftJoin('r.vehicle', 'v')
            ->andWhere('r.driver = :driver')
            ->andWhere('r.type = :type')
            ->andWhere(
                $qb->expr()->andX(
                    $qb->expr()->lte('r.startedAt', ':dateTo'),
                    $qb->expr()->gte('r.finishedAt', ':dateFrom')
                )
            )
            ->setParameter('driver', $driver)
            ->setParameter('dateFrom', $dateFrom)
            ->setParameter('dateTo', $dateTo)
            ->setParameter('type', Route::TYPE_DRIVING)
            ->getQuery()
            ->getResult();
    }

    public function createTempRouteTableByDateRange(string $vehicleIds, Carbon $dateFrom, Carbon $dateTo, string $table)
    {
        $sql = "CREATE TABLE IF NOT EXISTS $table AS (SELECT r.scope AS scope, 
        CONCAT(u.name,' ',u.surname) AS driver_name, r.started_at, r.finished_at, r.vehicle_id, r.distance
FROM route r
         LEFT JOIN users u ON r.driver_id = u.id
WHERE r.vehicle_id IN ($vehicleIds) and r.type = ?
  AND (r.started_at <= ? AND r.finished_at >= ?))";
        $stmt = $this->getEntityManager()
            ->getConnection()->prepare($sql);
        $stmt->bindValue(1, Route::TYPE_DRIVING);
        $stmt->bindValue(2, $dateTo->setTimezone('UTC'));
        $stmt->bindValue(3, $dateFrom->setTimezone('UTC'));
        $stmt->executeQuery();

        $indexSql = "CREATE INDEX IF NOT EXISTS temp_vehicle_id_idx ON $table (vehicle_id)";
        $stmt = $this->getEntityManager()->getConnection()->prepare($indexSql);
        $stmt->executeQuery();

        return $stmt->executeQuery();
    }

    public function findRoutesFromTempTable(int $vehicle, $dateFrom, $dateTo, string $table)
    {
        $qb = $this->getEntityManager()->createQueryBuilder();

        return $this
            ->getEntityManager()
            ->getConnection()
            ->createQueryBuilder()
            ->select('r.scope, r.driver_name, r.started_at, r.finished_at, r.distance')
            ->from($table, 'r')
            ->andWhere('r.vehicle_id = :vehicleId')
            ->andWhere(
                $qb->expr()->andX(
                    $qb->expr()->lte('r.started_at', ':dateTo'),
                    $qb->expr()->gte('r.finished_at', ':dateFrom')
                )
            )
            ->setParameter('table', $table)
            ->setParameter('vehicleId', $vehicle)
            ->setParameter('dateFrom', $dateFrom->setTimezone('UTC'))
            ->setParameter('dateTo', $dateTo->setTimezone('UTC'))
            ->execute()->fetchAllAssociative();
    }

    public function dropRouteTempTable(string $table)
    {
        $sql = "DROP TABLE IF EXISTS $table";
        $stmt = $this->getEntityManager()->getConnection()->prepare($sql);

        return $stmt->executeQuery();
    }

    public function findFirstRoute(User $user): ?Route
    {
        $qb = $this->getEntityManager()->createQueryBuilder();

        return $qb->select('r')
            ->from(Route::class, 'r')
            ->andWhere('r.driver = :driver')
            ->setParameter('driver', $user)
            ->orderBy('r.id', 'asc')
            ->setMaxResults(1)
            ->getQuery()->getOneOrNullResult();
    }

    public function findUsersFirstRoute(array $userIds): ?array
    {
        $rTable = $this->getEntityManager()->getClassMetadata(Route::class)->getTableName();

        return $this->getEntityManager()->getConnection()->createQueryBuilder()
            ->select('DISTINCT on (driver_id) driver_id, r.started_at')
            ->from($rTable, 'r')
            ->where('r.driver_id IN (:driverIds)')
            ->setParameter('driverIds', $userIds, Connection::PARAM_INT_ARRAY)
            ->orderBy('r.driver_id, r.id', Criteria::ASC)
            ->execute()->fetchAllAssociative();
    }

    public function findFirstRouteByVehicle(array $vehicleIds): ?array
    {
        $qb = $this->getEntityManager()->createQueryBuilder();

        return $qb->select('min(r.startedAt) as startedAt, IDENTITY(r.vehicle) as vehicleId')
            ->from(Route::class, 'r')
            ->andWhere('IDENTITY(r.vehicle) IN (:vehicleIds)')
            ->setParameter('vehicleIds', $vehicleIds, Connection::PARAM_INT_ARRAY)
            ->groupBy('r.vehicle')
//            ->orderBy('r.id', 'asc')
//            ->indexBy('r', 'vv.id')
            ->getQuery()->getResult();
    }

    public function getRouteIterable(Vehicle $vehicle, $dateFrom, $dateTo)
    {
        $query = $this->getEntityManager()
            ->createQueryBuilder()
            ->select('r')
            ->from(Route::class, 'r')
            ->andWhere('r.vehicle = :vehicle')
            ->andWhere('r.type = :type')
            ->setParameter('vehicle', $vehicle)
            ->setParameter('type', Route::TYPE_DRIVING)
            ->orderBy('r.id', 'DESC');

        if ($dateFrom) {
            $query->andWhere('r.startedAt > :tsFrom')
                ->setParameter('tsFrom', $dateFrom);
        }
        if ($dateTo) {
            $query->andWhere('r.finishedAt < :tsTo')
                ->setParameter('tsTo', $dateTo);
        }

        return $query->getQuery();
    }

    public function getRouteIterableByVehicleId(int $vehicleId, $dateFrom, $dateTo): Query
    {
        $query = $this->getEntityManager()
            ->createQueryBuilder()
            ->select('r')
            ->from(Route::class, 'r')
            ->andWhere('IDENTITY(r.vehicle) = :vehicleId')
            ->setParameter('vehicleId', $vehicleId)
            ->orderBy('r.id', 'DESC');

        if ($dateFrom) {
            $query->andWhere('r.startedAt < :tsTo')->setParameter('tsTo', $dateTo);
        }
        if ($dateTo) {
            $query->andWhere('r.finishedAt > :tsFrom')->setParameter('tsFrom', $dateFrom);
        }

        return $query->getQuery();
    }

    public function getRouteIdByDeviceIdAndTs($deviceId, $ts): ?int
    {
        $result = $this->getEntityManager()
            ->createQueryBuilder()
            ->select('r.id')
            ->from(Route::class, 'r')
            ->where('IDENTITY(r.device) = :deviceId')
            ->andWhere('r.startedAt <= :ts')
            ->andWhere('r.finishedAt >= :ts')
            ->setParameter('deviceId', $deviceId)
            ->setParameter('ts', $ts)
            ->getQuery()
            ->setMaxResults(1)
            ->getOneOrNullResult();

        return $result['id'] ?? null;
    }

    /**
     * @param Device $device
     * @param int $odoDiff
     * @param int|null $dayDiff
     * @param string|null $startedAtFrom
     * @param string|null $startedAtTo
     * @return Query
     */
    public function getRoutesWithWrongStartAndFinishOdometerQuery(
        Device $device,
        int $odoDiff,
        ?int $dayDiff = null,
        ?string $startedAtFrom = null,
        ?string $startedAtTo = null,
    ): Query {
        $query = $this->getEntityManager()
            ->createQueryBuilder()
            ->select('r')
            ->from(Route::class, 'r')
            ->where('IDENTITY(r.device) = :deviceId')
            ->andWhere('r.startOdometer IS NOT NULL')
            ->andWhere('r.finishOdometer IS NOT NULL')
            ->andWhere('r.finishedAt IS NOT NULL')
            ->andWhere('ABS(r.startOdometer - r.finishOdometer) > :odoDiff')
            ->setParameter('deviceId', $device->getId())
            ->setParameter('odoDiff', $odoDiff);

        if ($startedAtFrom) {
            $query->andWhere('r.startedAt >= :startedAtFrom')
                ->setParameter('startedAtFrom', $startedAtFrom);
        }
        if ($startedAtTo) {
            $query->andWhere('r.startedAt <= :startedAtTo')
                ->setParameter('startedAtTo', $startedAtTo);
        }
        if ($dayDiff) {
            $query->andWhere(
                'extract(epoch from (CAST(r.finishedAt AS timestamp) - CAST(r.startedAt AS timestamp))) > :secDiff'
            )
                ->setParameter('secDiff', $dayDiff * 24 * 60 * 60);
        }

        return $query->getQuery();
    }

    public function getDistanceByDriver(User $driver, $dateFrom, $dateTo)
    {
        $result = $this->getEntityManager()->getConnection()->createQueryBuilder()
            ->select('SUM(r.distance) as distance')
            ->from($this->getEntityManager()->getClassMetadata(Route::class)->getTableName(), 'r')
            ->where('r.driver_id = :driverId')
            ->andWhere('r.started_at <= :dateTo')
            ->andWhere('r.finished_at >= :dateFrom')
            ->andWhere('r.type = :routeType')
            ->setParameter('driverId', $driver->getId())
            ->setParameter('dateFrom', $dateFrom)
            ->setParameter('dateTo', $dateTo)
            ->setParameter('routeType', Route::TYPE_DRIVING)
            ->groupBy('r.driver_id')
            ->execute()
            ->fetchAssociative();

        return $result['distance'] ?? null;
    }
}
