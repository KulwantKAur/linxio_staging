<?php

namespace App\Repository\Tracker;

use App\Entity\Device;
use App\Entity\DriverHistory;
use App\Entity\Route;
use App\Entity\RouteTemp;
use App\Entity\Setting;
use App\Entity\Speeding;
use App\Entity\Tracker\TrackerHistory;
use App\Entity\Tracker\TrackerPayload;
use App\Entity\User;
use App\Entity\UserGroup;
use App\Entity\Vehicle;
use App\Service\DrivingBehavior\DrivingBehaviorService;
use App\Service\Tracker\Parser\Topflytech\Data;
use App\Service\Tracker\TrackerService;
use App\Util\DateHelper;
use App\Util\GeoHelper;
use App\Util\RouteHelper;
use Carbon\Carbon;
use Doctrine\Common\Collections\Criteria;
use Doctrine\Common\Collections\Order;
use Doctrine\DBAL\Connection;
use Doctrine\ORM\Query;
use Doctrine\ORM\QueryBuilder;

/**
 * TrackerHistoryRepository
 *
 * This class was generated by the Doctrine ORM. Add your own custom
 * repository methods below.
 */
class TrackerHistoryRepository extends \Doctrine\ORM\EntityRepository
{
    /**
     * @param Device $device
     * @param string|\DateTimeInterface $ts
     * @return bool
     * @throws \Doctrine\ORM\NonUniqueResultException
     */
    public function recordExistsForDevice(Device $device, $ts): bool
    {
        $result = $this->getEntityManager()
            ->createQueryBuilder()
            ->select('th.id')
            ->from(TrackerHistory::class, 'th')
            ->where('th.device = :device')
            ->andWhere('th.ts = :ts')
            ->setParameter('ts', $ts)
            ->setParameter('device', $device)
            ->getQuery()
            ->setMaxResults(1)
            ->getOneOrNullResult();

        return boolval($result);
    }

    /**
     * @param Device $device
     * @param string $dateFrom
     * @param string $dateTo
     * @return mixed
     * @throws \Exception
     */
    public function getCoordinatesByDevice(Device $device, $dateFrom, $dateTo)
    {
        return $this->getEntityManager()
            ->createQueryBuilder()
            ->select(['th.lat', 'th.lng', 'th.ts'])
            ->from(TrackerHistory::class, 'th')
            ->where('th.device = :device')
            ->andWhere('th.ts >= :dateFrom')
            ->andWhere('th.ts < :dateTo')
            ->andWhere('th.ts < :now')
            ->andWhere('th.lat <> 0')
            ->andWhere('th.lng <> 0')
            ->andWhere('th.lat IS NOT NULL')
            ->andWhere('th.lng IS NOT NULL')
            ->setParameter('device', $device)
            ->setParameter('dateFrom', $dateFrom)
            ->setParameter('dateTo', $dateTo)
            ->setParameter('now', new \DateTime())
            ->orderBy('th.ts')
            ->getQuery()
            ->getResult();
    }

    /**
     * @param string $imei
     * @param string $dateFrom
     * @param string $dateTo
     * @return mixed
     * @throws \Doctrine\ORM\NonUniqueResultException
     */
    public function getCoordinatesCount($imei, $dateFrom, $dateTo)
    {
        return $this->getEntityManager()
            ->createQueryBuilder()
            ->select('COUNT(th.ts)')
            ->from(TrackerHistory::class, 'th')
            ->leftJoin('th.trackerPayload', 'tp')
            ->leftJoin('tp.trackerAuth', 'ta')
            ->where('ta.imei = :imei')
            ->andWhere('th.ts >= :dateFrom')
            ->andWhere('th.ts < :dateTo')
            ->setParameter('imei', $imei)
            ->setParameter('dateFrom', $dateFrom)
            ->setParameter('dateTo', $dateTo)
            ->getQuery()
            ->getSingleScalarResult();
    }

    /**
     * @param Device $device
     * @param string $dateFrom
     * @param string $dateTo
     * @return mixed
     */
    public function getQueryDataForTeltonikaLogs(Device $device, $dateFrom, $dateTo)
    {
        return $this->getEntityManager()
            ->createQueryBuilder()
            ->select('th.lat, th.lng, th.id, th.speed, th.angle, th.createdAt, th.ts, th.extraData AS ioFromExtraData, th.odometer, th.movement, th.ignition, th.batteryVoltage, th.batteryVoltagePercentage, th.temperatureLevel, th.externalVoltage')
            ->addSelect(
                'string_agg(
                CONCAT(
                    \'[\',
                    cast(e.remoteId as string),
                    \']: \',
                    cast(tsd.eventValue as string)
                ),
             \', \') AS ioFromEvents'
            )
            ->from(TrackerHistory::class, 'th')
            ->leftJoin('th.trackerSensorData', 'tsd')
            ->leftJoin('tsd.event', 'e')
            ->where('th.device = :device')
            ->andWhere('th.ts >= :dateFrom')
            ->andWhere('th.ts <= :dateTo')
            ->setParameter('device', $device)
            ->setParameter('dateFrom', $dateFrom)
            ->setParameter('dateTo', $dateTo)
            ->groupBy('th.id')
            ->orderBy('th.ts')
            ->getQuery();
    }

    /**
     * @param Device $device
     * @param string $dateFrom
     * @param string $dateTo
     * @return mixed
     */
    public function getQueryDataForUlbotechLogs(Device $device, $dateFrom, $dateTo)
    {
        return $this->getEntityManager()
            ->createQueryBuilder()
            ->select('tp.payload, th.lat, th.lng, th.id, th.speed, th.angle, th.createdAt, th.ts, th.odometer, th.movement, th.ignition, th.batteryVoltage, th.batteryVoltagePercentage, th.temperatureLevel, th.externalVoltage')
            ->from(TrackerHistory::class, 'th')
            ->leftJoin('th.trackerPayload', 'tp')
            ->where('th.device = :device')
            ->andWhere('th.ts >= :dateFrom')
            ->andWhere('th.ts <= :dateTo')
            ->setParameter('device', $device)
            ->setParameter('dateFrom', $dateFrom)
            ->setParameter('dateTo', $dateTo)
            ->orderBy('th.ts')
            ->getQuery();
    }

    /**
     * @param Device $device
     * @param string $dateFrom
     * @param string $dateTo
     * @return mixed
     */
    public function getQueryDataForTopflytechLogs(Device $device, $dateFrom, $dateTo)
    {
        return $this->getEntityManager()
            ->createQueryBuilder()
            ->select('tp.payload, th.lat, th.lng, th.id, th.speed, th.angle, th.createdAt, th.ts, th.extraData, th.odometer, th.movement, th.ignition, th.batteryVoltage, th.batteryVoltagePercentage, th.temperatureLevel, th.externalVoltage')
            ->from(TrackerHistory::class, 'th')
            ->leftJoin('th.trackerPayload', 'tp')
            ->where('th.device = :device')
            ->andWhere('th.ts >= :dateFrom')
            ->andWhere('th.ts <= :dateTo')
            ->setParameter('device', $device)
            ->setParameter('dateFrom', $dateFrom)
            ->setParameter('dateTo', $dateTo)
            ->orderBy('th.ts')
            ->getQuery();
    }

    /**
     * @param Device $device
     * @param string $dateFrom
     * @param string $dateTo
     * @return mixed
     */
    public function getQueryDataForPivotelLogs(Device $device, $dateFrom, $dateTo)
    {
        return $this->getEntityManager()
            ->createQueryBuilder()
            ->select('tp.payload, th.lat, th.lng, th.id, th.createdAt, th.ts, th.odometer, th.movement, th.ignition, th.batteryVoltage, th.batteryVoltagePercentage, th.temperatureLevel, th.externalVoltage')
            ->from(TrackerHistory::class, 'th')
            ->leftJoin('th.trackerPayload', 'tp')
            ->where('th.device = :device')
            ->andWhere('th.ts >= :dateFrom')
            ->andWhere('th.ts <= :dateTo')
            ->setParameter('device', $device)
            ->setParameter('dateFrom', $dateFrom)
            ->setParameter('dateTo', $dateTo)
            ->orderBy('th.ts')
            ->getQuery();
    }

    /**
     * @param Device $device
     * @param string $dateFrom
     * @param string $dateTo
     * @return mixed
     */
    public function getQueryDataForTraccarLogs(Device $device, $dateFrom, $dateTo)
    {
        return $this->getEntityManager()
            ->createQueryBuilder()
            ->select('th.lat, th.lng, th.id, th.speed, th.angle, th.createdAt, th.ts, th.extraData, th.odometer, th.movement, th.ignition, tp.payload, th.batteryVoltage, th.batteryVoltagePercentage, th.temperatureLevel, th.externalVoltage')
            ->from(TrackerHistory::class, 'th')
            ->leftJoin('th.trackerPayload', 'tp')
            ->where('th.device = :device')
            ->andWhere('th.ts >= :dateFrom')
            ->andWhere('th.ts <= :dateTo')
            ->setParameter('device', $device)
            ->setParameter('dateFrom', $dateFrom)
            ->setParameter('dateTo', $dateTo)
            ->orderBy('th.ts')
            ->getQuery();
    }

    /**
     * @param Device $device
     * @param string $dateFrom
     * @param string $dateTo
     * @return Query
     */
    public function getQueryDataForStreamaxLogs(Device $device, $dateFrom, $dateTo)
    {
        return $this->getEntityManager()
            ->createQueryBuilder()
            ->select('th.lat, th.lng, th.id, th.speed, th.angle, th.createdAt, th.ts, th.extraData, th.odometer, th.movement, th.ignition, tp.payload, th.batteryVoltage, th.temperatureLevel, th.externalVoltage')
            ->from(TrackerHistory::class, 'th')
            ->leftJoin('th.trackerPayload', 'tp')
            ->where('th.device = :device')
            ->andWhere('th.ts >= :dateFrom')
            ->andWhere('th.ts <= :dateTo')
            ->setParameter('device', $device)
            ->setParameter('dateFrom', $dateFrom)
            ->setParameter('dateTo', $dateTo)
            ->orderBy('th.ts')
            ->getQuery();
    }

    /**
     * @param int $deviceId
     * @param string $dateFrom
     * @param string $dateTo
     * @return mixed
     * @throws \Exception
     */
    public function getCoordinatesByDeviceId($deviceId, $dateFrom, $dateTo, $timezone = null)
    {
        $query = $this->getQueryCoordinatesByDeviceId($deviceId, $dateFrom, $dateTo);

        $coordinates = $query->getQuery()->getResult();

        foreach ($coordinates as $key => $coordinate) {
            $date = $timezone
                ? (clone $coordinate['ts'])->setTimezone(new \DateTimeZone($timezone))
                : $coordinate['ts'];
            $coordinates[$key]['ts'] = DateHelper::formatDate($date);
        }

        return $coordinates;
    }

    public function getSingleCoordinateByDeviceId(
        $deviceId,
        $dateFrom,
        $dateTo,
        $timezone = null
    ) {
        $query = $this->getQuerySingleCoordinatePerHourByDeviceId($deviceId, $dateFrom, $dateTo);

        $coordinates = $query->getQuery()->getResult();

        foreach ($coordinates as $key => $coordinate) {
            $date = $timezone
                ? (clone $coordinate['ts'])->setTimezone(new \DateTimeZone($timezone))
                : $coordinate['ts'];
            $coordinates[$key]['ts'] = DateHelper::formatDate($date);
        }

        return $coordinates;
    }

    /**
     * @param int $deviceId
     * @param string $dateFrom
     * @param string $dateTo
     * @return mixed
     */
    public function getQueryCoordinatesByDeviceId($deviceId, $dateFrom, $dateTo)
    {
        return $this->getEntityManager()
            ->createQueryBuilder()
            ->select('th.lat, th.lng, th.ts')
            ->from(TrackerHistory::class, 'th')
            ->where('IDENTITY(th.device) = :deviceId')
            ->andWhere('th.ts >= :dateFrom')
            ->andWhere('th.ts <= :dateTo')
            ->andWhere('th.lat <> 0')
            ->andWhere('th.lng <> 0')
            ->andWhere('th.lat IS NOT NULL')
            ->andWhere('th.lng IS NOT NULL')
            ->setParameter('deviceId', $deviceId)
            ->setParameter('dateFrom', $dateFrom)
            ->setParameter('dateTo', $dateTo)
            ->orderBy('th.ts');
    }

    public function getQuerySingleCoordinatePerHourByDeviceId($deviceId, $dateFrom, $dateTo)
    {
        $thTable = $this->getEntityManager()->getClassMetadata(TrackerHistory::class)->getTableName();
        $qb = $this->getEntityManager()->getConnection()->createQueryBuilder();

        $ids = $qb->select('min(th.id) as id, trunc(EXTRACT(hour from th.ts)) as hour')
            ->from($thTable, 'th')
            ->where('th.device_id = :deviceId')
            ->andWhere('th.ts >= :dateFrom')
            ->andWhere('th.ts < :dateTo')
            ->andWhere('th.lat <> 0')
            ->andWhere('th.lng <> 0')
            ->andWhere('th.lat IS NOT NULL')
            ->andWhere('th.lng IS NOT NULL')
            ->setParameter('deviceId', $deviceId)
            ->setParameter('dateFrom', $dateFrom)
            ->setParameter('dateTo', $dateTo)
            ->groupBy('hour')
            ->execute()
            ->fetchAll();
        $ids = $ids ? array_column($ids, 'id') : null;

        return $this->getEntityManager()
            ->createQueryBuilder()
            ->select('th.lat, th.lng, th.ts')
            ->from(TrackerHistory::class, 'th')
            ->andWhere('th.id IN (:ids)')
            ->setParameter('ids', $ids)
            ->orderBy('th.ts');
    }

    /**
     * @param int $deviceId
     * @param Carbon $dateFrom
     * @param Carbon $dateTo
     * @return mixed
     * @throws \Doctrine\ORM\NonUniqueResultException
     */
    public function getHourlyCoordinatesByDeviceId($deviceId, $dateFrom, $dateTo)
    {
        $data = [];
        $dateCurrent = (clone $dateFrom)->startOfHour();
        $dateNextHour = (clone $dateCurrent)->addHour();

        for ($i = 0; $dateCurrent->getTimestamp() <= $dateTo->getTimestamp(); $i++) {
            $dateWithStartHour = (clone $dateCurrent)->startOfHour();
            $data[$i]['date'] = $dateWithStartHour->toIso8601String();
            $data[$i]['coordinates'] = $this->getCoordinatesByDeviceId($deviceId, $dateCurrent, $dateNextHour);
            $dateCurrent->addHour();
            $dateNextHour->addHour();
        }

        return $data;
    }

    /**
     * @param $deviceId
     * @param $dateFrom
     * @param $dateTo
     * @param mixed $timezone
     * @return array
     * @throws \Exception
     */
    public function getDailyCoordinatesByDeviceId(
        $deviceId,
        Carbon $dateFrom,
        Carbon $dateTo,
        $timezone = null
    ) {
        $data = [];
        $dateCurrent = (clone $dateFrom);
        $dateToStartDay = (clone $dateTo)->startOfDay();

        for ($i = 0; (clone $dateCurrent)->getTimestamp() <= $dateToStartDay->getTimestamp(); $i++) {
            $dateWithStartDay = (clone $dateCurrent)->startOfDay();
            $data[$i]['date'] = $dateWithStartDay->toIso8601String();
            $data[$i]['coordinates'] = $this->getCoordinatesByDeviceId(
                $deviceId,
                (clone $dateCurrent)->startOfDay()->setTimezone('UTC'),
                (clone $dateCurrent)->startOfDay()->addDay()->setTimezone('UTC'),
                $timezone
            );
            $dateCurrent->addDay();
        }

        return $data;
    }

    public function getOnePerHourCoordinateByDeviceId(
        $deviceId,
        Carbon $dateFrom,
        Carbon $dateTo,
        $timezone = null
    ) {
        $data = [];
        $dateCurrent = (clone $dateFrom);
        $dateToStartDay = (clone $dateTo)->startOfDay();

        for ($i = 0; (clone $dateCurrent)->getTimestamp() <= $dateToStartDay->getTimestamp(); $i++) {
            $dateWithStartDay = (clone $dateCurrent)->startOfDay();
            $data[$i]['date'] = $dateWithStartDay->toIso8601String();
            $data[$i]['coordinates'] = $this->getSingleCoordinateByDeviceId(
                $deviceId,
                (clone $dateCurrent)->startOfDay()->setTimezone('UTC'),
                (clone $dateCurrent)->startOfDay()->addDay()->setTimezone('UTC'),
                $timezone
            );
            $dateCurrent->addDay();
        }

        return $data;
    }

    /**
     * @param Device $device
     * @return mixed|TrackerHistory
     * @throws \Doctrine\ORM\NonUniqueResultException
     */
    public function getLastRecordByDevice(Device $device): ?TrackerHistory
    {
        return $this->getEntityManager()
            ->createQueryBuilder()
            ->select('th')
            ->from(TrackerHistory::class, 'th')
            ->where('th.device = :device')
            ->setParameter('device', $device)
            ->orderBy('th.ts', Criteria::DESC)
            ->getQuery()
            ->setMaxResults(1)
            ->getOneOrNullResult();
    }

    /**
     * @param Device $device
     * @param $date
     * @return mixed|TrackerHistory
     * @throws \Doctrine\ORM\NonUniqueResultException
     */
    public function getLastTrackerRecordByDeviceAndDate(Device $device, $date): ?TrackerHistory
    {
        return $this->getEntityManager()
            ->createQueryBuilder()
            ->select('th')
            ->from(TrackerHistory::class, 'th')
            ->where('th.device = :device')
            ->andWhere('th.ts <= :date')
            ->setParameter('device', $device)
            ->setParameter('date', $date)
            ->orderBy('th.ts', Criteria::DESC)
            ->getQuery()
            ->setMaxResults(1)
            ->getOneOrNullResult();
    }

    /**
     * @param Device $device
     * @param $date
     * @return null|array
     * @throws \Doctrine\ORM\NonUniqueResultException
     */
    public function getLastTrackerCoordinatesByDevice(Device $device, $date): ?array
    {
        return $this->getEntityManager()
            ->createQueryBuilder()
            ->select('th.lat, th.lng')
            ->from(TrackerHistory::class, 'th')
            ->where('th.device = :device')
            ->andWhere('th.ts <= :date')
            ->setParameter('device', $device)
            ->setParameter('date', $date)
            ->orderBy('th.ts', Criteria::DESC)
            ->getQuery()
            ->setMaxResults(1)
            ->getOneOrNullResult();
    }

    /**
     * @param Vehicle $vehicle
     * @param $dateFrom
     * @param $dateLimit
     * @param bool $takePrevious
     * @return null|array
     * @throws \Doctrine\ORM\NonUniqueResultException
     */
    public function getClosestOdometerAndTsByVehicleAndDate(
        Vehicle $vehicle,
                $dateFrom,
                $dateLimit,
        bool    $takePrevious = true
    ): ?array {
        $dateCondition = $takePrevious ? 'th.ts <= :dateFrom' : 'th.ts >= :dateFrom';
        $dateLimitCondition = $takePrevious ? 'th.ts > :dateLimit' : 'th.ts < :dateLimit';
        $orderBy = $takePrevious ? Criteria::DESC : Criteria::ASC;

        return $this->getEntityManager()
            ->createQueryBuilder()
            ->select('th.odometer, th.ts')
            ->from(TrackerHistory::class, 'th')
            ->where('th.vehicle = :vehicle')
            ->andWhere('th.odometer IS NOT NULL')
            ->andWhere($dateCondition)
            ->andWhere($dateLimitCondition)
            ->setParameter('vehicle', $vehicle)
            ->setParameter('dateFrom', $dateFrom)
            ->setParameter('dateLimit', $dateLimit)
            ->orderBy('th.ts', $orderBy)
            ->getQuery()
            ->setMaxResults(1)
            ->getOneOrNullResult();
    }

    /**
     * @param Vehicle $vehicle
     * @return null|array
     * @throws \Doctrine\ORM\NonUniqueResultException
     */
    public function getLastRecordByVehicle(Vehicle $vehicle): ?TrackerHistory
    {
        return $this->getEntityManager()
            ->createQueryBuilder()
            ->select('th')
            ->from(TrackerHistory::class, 'th')
            ->where('th.vehicle = :vehicle')
            ->andWhere('th.odometer IS NOT NULL')
            ->setParameter('vehicle', $vehicle)
            ->orderBy('th.ts', Criteria::DESC)
            ->getQuery()
            ->setMaxResults(1)
            ->getOneOrNullResult();
    }

    /**
     * @param Vehicle $vehicle
     * @param $date
     * @return mixed|TrackerHistory
     * @throws \Doctrine\ORM\NonUniqueResultException
     */
    public function getLastTrackerRecordByVehicleAndDate(Vehicle $vehicle, $date): ?TrackerHistory
    {
        return $this->getEntityManager()
            ->createQueryBuilder()
            ->select('th')
            ->from(TrackerHistory::class, 'th')
            ->where('th.vehicle = :vehicle')
            ->andWhere('th.ts <= :date')
            ->setParameter('vehicle', $vehicle)
            ->setParameter('date', $date)
            ->orderBy('th.ts', Criteria::DESC)
            ->getQuery()
            ->setMaxResults(1)
            ->getOneOrNullResult();
    }

    public function getNextTrackerRecordByVehicleAndDate(Vehicle $vehicle, $date): ?TrackerHistory
    {
        return $this->getEntityManager()
            ->createQueryBuilder()
            ->select('th')
            ->from(TrackerHistory::class, 'th')
            ->where('th.vehicle = :vehicle')
            ->andWhere('th.ts >= :date')
            ->setParameter('vehicle', $vehicle)
            ->setParameter('date', $date)
            ->orderBy('th.ts', Criteria::ASC)
            ->getQuery()
            ->setMaxResults(1)
            ->getOneOrNullResult();
    }

    /**
     * @param Device $device
     * @param $date
     * @return TrackerHistory|null
     * @throws \Doctrine\ORM\NonUniqueResultException
     */
    public function getFirstTrackerRecordsByDeviceWithIgnition(Device $device, $date): ?TrackerHistory
    {
        return $this->getEntityManager()
            ->createQueryBuilder()
            ->select('th')
            ->from(TrackerHistory::class, 'th')
            ->where('th.device = :device')
            ->andWhere('th.ts < :date')
            ->andWhere('th.ignition = 1')
            ->setParameter('device', $device)
            ->setParameter('date', $date)
            ->orderBy('th.ts', Criteria::DESC)
            ->getQuery()
            ->setMaxResults(1)
            ->getOneOrNullResult();
    }

    /**
     * @return null|array
     */
    public function getNotCalculatedRoutesDeviceIds(): ?array
    {
        $result = $this->getEntityManager()
            ->createQueryBuilder()
            ->select('DISTINCT IDENTITY(th.device) AS device_id')
            ->from(TrackerHistory::class, 'th')
            ->where('th.isCalculated = false')
            ->getQuery()
            ->getResult();

        return $result ? array_column($result, 'device_id') : [];
    }

    /**
     * @return null|array
     */
    public function getNotCalculatedIdlingDeviceIds(): ?array
    {
        $result = $this->getEntityManager()
            ->createQueryBuilder()
            ->select('DISTINCT IDENTITY(th.device) AS device_id')
            ->from(TrackerHistory::class, 'th')
            ->where('th.isCalculatedIdling = false')
            ->getQuery()
            ->getResult();

        return $result ? array_column($result, 'device_id') : [];
    }

    /**
     * @return null|array
     */
    public function getNotCalculatedSpeedingDeviceIds(): ?array
    {
        $result = $this->getEntityManager()
            ->createQueryBuilder()
            ->select('DISTINCT IDENTITY(th.device) AS device_id')
            ->from(TrackerHistory::class, 'th')
            ->where('th.isCalculatedSpeeding = false')
            ->getQuery()
            ->getResult();

        return $result ? array_column($result, 'device_id') : [];
    }

    /**
     * @param int $deviceId
     * @param string|null $startedAt
     * @param string|null $finishedAt
     * @return mixed|TrackerHistory
     */
    public function getNotCalculatedRoutesTrackerMaxAndMinRecords(
        int     $deviceId,
        ?string $startedAt = null,
        ?string $finishedAt = null
    ): ?array {
        $qb = $this->getEntityManager()
            ->createQueryBuilder();
        $query = $qb->select('MAX(th.ts) AS max_ts, MIN(th.ts) AS min_ts')
            ->from(TrackerHistory::class, 'th')
            ->where($qb->expr()->eq('IDENTITY(th.device)', $deviceId))
            ->andWhere('th.isCalculated = false');

        if ($startedAt) {
            $query->andWhere('th.ts >= :startedAt')
                ->setParameter('startedAt', $startedAt);
        }

        if ($finishedAt) {
            $query->andWhere('th.ts <= :finishedAt')
                ->setParameter('finishedAt', $finishedAt);
        }

        $result = $query->getQuery()->getResult();

        return $result ? $result[0] : [];
    }

    /**
     * @param $deviceId
     * @return mixed|TrackerHistory
     */
    public function getNotCalculatedIdlingTrackerMaxAndMinRecords($deviceId): ?array
    {
        $qb = $this->getEntityManager()
            ->createQueryBuilder();

        $result = $qb->select('MAX(th.ts) AS max_ts, MIN(th.ts) AS min_ts')
            ->from(TrackerHistory::class, 'th')
            ->where($qb->expr()->eq('IDENTITY(th.device)', $deviceId))
            ->andWhere('th.isCalculatedIdling = false')
            ->getQuery()
            ->getResult();

        return $result ? $result[0] : [];
    }

    /**
     * @param $deviceId
     * @return mixed|TrackerHistory
     */
    public function getNotCalculatedSpeedingTrackerMaxAndMinRecords($deviceId): ?array
    {
        $qb = $this->getEntityManager()
            ->createQueryBuilder();

        $result = $qb->select('MAX(th.ts) AS max_ts, MIN(th.ts) AS min_ts')
            ->from(TrackerHistory::class, 'th')
            ->where($qb->expr()->eq('IDENTITY(th.device)', $deviceId))
            ->andWhere('th.isCalculatedSpeeding = false')
            ->getQuery()
            ->getResult();

        return $result ? $result[0] : [];
    }

    public function getPreviousTrackerHistory(
        TrackerHistory $trackerHistory,
                       $dateFrom = null,
        bool           $withCoordinates = false
    ): ?TrackerHistory {
        $query = $this->getEntityManager()
            ->createQueryBuilder()
            ->select('th')
            ->from(TrackerHistory::class, 'th')
            ->where('th.device = :device')
            ->andWhere('th.ts < :dateTo')
            ->setParameter('device', $trackerHistory->getDevice())
            ->setParameter('dateTo', $trackerHistory->getTs())
            ->orderBy('th.ts', Criteria::DESC);

        if ($dateFrom) {
            $query->andWhere('th.ts >= :dateFrom')
                ->setParameter('dateFrom', $dateFrom);
        }
        if ($withCoordinates) {
            $query->andWhere('th.lat <> 0')
                ->andWhere('th.lng <> 0')
                ->andWhere('th.lat IS NOT NULL')
                ->andWhere('th.lng IS NOT NULL');
        }

        return $query->getQuery()->setMaxResults(1)->getOneOrNullResult();
    }

    /**
     * @param Device $device
     * @param \DateTimeInterface $dateTo
     * @param \DateTimeInterface|null $dateFrom
     * @return TrackerHistory|null
     * @throws \Doctrine\ORM\NonUniqueResultException
     */
    public function getPreviousTrackerHistoryByDeviceAndDate(Device $device, $dateTo, $dateFrom = null): ?TrackerHistory
    {
        $query = $this->getEntityManager()
            ->createQueryBuilder()
            ->select('th')
            ->from(TrackerHistory::class, 'th')
            ->where('th.device = :device')
            ->andWhere('th.ts < :dateTo')
            ->setParameter('device', $device)
            ->setParameter('dateTo', $dateTo)
            ->orderBy('th.ts', Criteria::DESC);

        if ($dateFrom) {
            $query->andWhere('th.ts >= :dateFrom')
                ->setParameter('dateFrom', $dateFrom);
        }

        return $query->getQuery()->setMaxResults(1)->getOneOrNullResult();
    }

    /**
     * @param Device $device
     * @param null $dateFrom
     * @param null $dateTo
     * @return mixed|TrackerHistory
     * @throws \Doctrine\ORM\NonUniqueResultException
     */
    public function getPastTrackerHistoryInRange(Device $device, $dateFrom = null, $dateTo = null): ?TrackerHistory
    {
        $query = $this->getEntityManager()
            ->createQueryBuilder()
            ->select('th')
            ->from(TrackerHistory::class, 'th')
            ->where('th.device = :device')
            ->setParameter('device', $device)
            ->orderBy('th.ts', Criteria::DESC);

        if ($dateFrom) {
            $query->andWhere('th.ts >= :dateFrom')
                ->setParameter('dateFrom', $dateFrom);
        }

        if ($dateTo) {
            $query->andWhere('th.ts <= :dateTo')
                ->setParameter('dateTo', $dateTo);
        }

        return $query->getQuery()->setMaxResults(1)->getOneOrNullResult();
    }

    /**
     * @param Device $device
     * @param \DateTimeInterface|string|null $dateFrom
     * @param \DateTimeInterface|string|null $dateTo
     * @param bool|null $order
     * @return mixed|TrackerHistory[]
     */
    public function getTrackerHistoriesInRange(
        Device $device,
               $dateFrom = null,
               $dateTo = null,
        bool   $order = null
    ): ?array {
        $query = $this->getEntityManager()
            ->createQueryBuilder()
            ->select('th')
            ->from(TrackerHistory::class, 'th')
            ->where('th.device = :device')
            ->setParameter('device', $device);

        if ($dateFrom) {
            $query->andWhere('th.ts >= :dateFrom')
                ->setParameter('dateFrom', $dateFrom);
        }
        if ($dateTo) {
            $query->andWhere('th.ts <= :dateTo')
                ->setParameter('dateTo', $dateTo);
        }
        if ($order) {
            $query->orderBy('th.ts', Criteria::ASC);
        }

        return $query->getQuery()->getResult();
    }

    /**
     * @param $device
     * @param null $dateFrom
     * @param null $dateTo
     * @return mixed|TrackerHistory
     * @throws \Doctrine\ORM\NonUniqueResultException
     */
    public function getFutureTrackerHistoryInRange($device, $dateFrom = null, $dateTo = null): ?TrackerHistory
    {
        $query = $this->getEntityManager()
            ->createQueryBuilder()
            ->select('th')
            ->from(TrackerHistory::class, 'th')
            ->where('th.device = :device')
            ->setParameter('device', $device)
            ->orderBy('th.ts', Criteria::ASC);

        if ($dateFrom) {
            $query->andWhere('th.ts >= :dateFrom')
                ->setParameter('dateFrom', $dateFrom);
        }

        if ($dateTo) {
            $query->andWhere('th.ts <= :dateTo')
                ->setParameter('dateTo', $dateTo);
        }

        return $query->getQuery()->setMaxResults(1)->getOneOrNullResult();
    }

    /**
     * @param TrackerHistory $trackerHistory
     * @return \DateTime|null
     * @throws \Doctrine\ORM\NonUniqueResultException
     */
    public function getNextTrackerHistoryDateWithIgnition(TrackerHistory $trackerHistory): ?\DateTime
    {
        $result = $this->getEntityManager()
            ->createQueryBuilder()
            ->select('th.ts')
            ->from(TrackerHistory::class, 'th')
            ->where('th.device = :device')
            ->andWhere('th.ts > :date')
            ->setParameter('device', $trackerHistory->getDevice())
            ->setParameter('date', $trackerHistory->getTs())
            ->orderBy('th.ts', Criteria::ASC)
            ->getQuery()
            ->setMaxResults(1)
            ->getOneOrNullResult();

        return $result ? $result['ts'] : null;
    }

    /**
     * @param RouteTemp $route
     * @return Query
     */
    public function getHistoriesByRouteTemp(RouteTemp $route): Query
    {
        return $this->getEntityManager()
            ->createQueryBuilder()
            ->select('th.id, th.movement, th.ignition')
            ->from(TrackerHistory::class, 'th')
            ->where('th.device = :device')
            ->andWhere('th.ts >= :dateFrom')
            ->andWhere('th.ts <= :dateTo')
            ->setParameter('device', $route->getDevice())
            ->setParameter('dateFrom', $route->getStartedAt())
            ->setParameter('dateTo', $route->getFinishedAt())
            ->orderBy('th.ts', Criteria::DESC)
            ->getQuery();
    }

    /**
     * @param Route $route
     * @return array|null
     */
    public function getHistoriesDataByRoute(Route $route): ?array
    {
        $query = $this->getEntityManager()
            ->createQueryBuilder()
            ->select('th.movement, th.ignition, th.ts, th.odometer, th.speed')
            ->from(TrackerHistory::class, 'th')
            ->where('th.device = :device')
            ->andWhere('th.ts >= :dateFrom')
            ->andWhere('th.ts <= :dateTo')
            ->andWhere('th.odometer IS NOT NULL')
            ->setParameter('device', $route->getDevice())
            ->setParameter('dateFrom', $route->getStartedAt())
            ->setParameter('dateTo', $route->getFinishedAt())
            ->orderBy('th.ts', Criteria::DESC)
            ->getQuery();

        return $query->getResult();
    }

    /**
     * @param Device $device
     * @return int|mixed|string|null
     */
    public function getLastTrackerHistoryByDevice(Device $device)
    {
        $result = $this->getEntityManager()
            ->createQueryBuilder()
            ->select('th')
            ->from(TrackerHistory::class, 'th')
            ->where('th.device = :device')
            ->setParameter('device', $device)
            ->orderBy('th.createdAt', Criteria::DESC)
            ->getQuery()
            ->setMaxResults(1)
            ->execute();

        return $result ?? null;
    }

    /**
     * @param Device $device
     * @param \DateTimeInterface|null $date
     * @return int|mixed|string|null
     * @throws \Doctrine\ORM\NonUniqueResultException
     */
    public function getLastOccurredTrackerHistoryByDevice(Device $device, ?\DateTimeInterface $date)
    {
        $query = $this->getEntityManager()
            ->createQueryBuilder()
            ->select('th')
            ->from(TrackerHistory::class, 'th')
            ->where('th.device = :device')
            ->setParameter('device', $device)
            ->orderBy('th.ts', Criteria::DESC);

        if ($date) {
            $query->andWhere('th.ts <= :date')
                ->setParameter('date', $date);
        }

        $result = $query->getQuery()->setMaxResults(1)->execute();

        return $result ?? null;
    }

    /**
     * @param Route $deviceRoute
     * @param array $selectData
     * @param bool $withLastCoordinates
     * @return array|null
     * @throws \Exception
     */
    public function getCoordinatesByDeviceRoute(
        Route $deviceRoute,
              $selectData = [],
              $withLastCoordinates = false
    ): ?array {
        $qb = $this->getEntityManager()
            ->createQueryBuilder();

        $qb = $qb->select('th.id, th.lat, th.lng, th.ts')
            ->from(TrackerHistory::class, 'th')
            ->where('th.device = :device')
            ->andWhere('th.ts >= :dateFrom')
            ->setParameter('device', $deviceRoute->getDevice())
            ->setParameter('dateFrom', $deviceRoute->getStartedAt())
            ->orderBy('th.ts', Criteria::ASC);

        if (!$withLastCoordinates) {
            $qb->andWhere('th.ts <= :dateTo')
                ->setParameter('dateTo', $deviceRoute->getFinishedAt());
        }

        foreach ($selectData as $select) {
            $qb->addSelect('th.' . $select);
        }

        $coordinatesQuery = $qb->getQuery();
        $coordinates = [];

        foreach ($coordinatesQuery->toIterable() as $coordinate) {
            $coordinates[] = GeoHelper::convertCoordinatesForResponse($coordinate);
        }

        return $coordinates;
    }

    public function getCoordinatesByRouteWithOptimization(
        Route $deviceRoute,
              $selectData = [],
              $withLastCoordinates = false,
        array $params = []
    ): ?array {
        $qb = $this->getEntityManager()->createQueryBuilder();

        $qb = $qb
            ->from(TrackerHistory::class, 'th')
            ->where('th.device = :device')
            ->andWhere('th.ts >= :dateFrom')
            ->setParameter('device', $deviceRoute->getDevice())
            ->setParameter('dateFrom', $deviceRoute->getStartedAt());

        if (!$withLastCoordinates) {
            $qb->andWhere('th.ts <= :dateTo')
                ->setParameter('dateTo', $deviceRoute->getFinishedAt());
        }

        $coordinates = [];

        if ($params['type'] === 'angle') {
            $coordinatesQuery = $qb->select('th.id, th.lat, th.lng, th.ts, th.angle')
                ->orderBy('th.ts', Criteria::ASC);
            foreach ($selectData as $select) {
                $qb->addSelect('th.' . $select);
            }

            $coordinatesQuery = $coordinatesQuery->getQuery();
            $i = 0;
            $angleLimit = 10;

            foreach ($coordinatesQuery->toIterable() as $coordinate) {
                $prevAngle = $coordinates[$i - 1]['angle'] ?? null;
                $currentAngle = $coordinate['angle'];

                //optimization count of coordinates for UI (2 cases)
                if ($currentAngle && $deviceRoute->isDrivingType() && !empty($coordinates)) {
                    $prevAngleMin = ($prevAngle - $angleLimit) < 0 ? 360 - ($prevAngle - $angleLimit) : $prevAngle - $angleLimit;
                    $prevAngleMax = $prevAngle + $angleLimit > 360 ? ($prevAngle + $angleLimit) - 360 : $prevAngle + $angleLimit;

                    if ($currentAngle < $prevAngleMax && $currentAngle > $prevAngleMin) {
                        continue;
                    } elseif ($currentAngle < $prevAngle + $angleLimit && $currentAngle > $prevAngle - $angleLimit) {
                        continue;
                    }
                }
                $coordinates[$i] = GeoHelper::convertCoordinatesForResponse($coordinate);
                $i++;
            }
        }

        return $coordinates;
    }

    public static function getCoordinatesOptimisatedBySpeed(array $data, array $result, string $type): array
    {
        $max = self::getMaxItem($data, $type);
        $min = self::getMinItem($data, $type);

        if ($max[$type] - $result[count($result) - 1][$type] > $result[count($result) - 1][$type] - $min[$type]) {
            return GeoHelper::convertCoordinatesForResponse($max);
        } else {
            return GeoHelper::convertCoordinatesForResponse($min);
        }
    }

    public static function getMaxItem(array $data, string $type)
    {
        $max = $data[0] ?? null;
        for ($i = 0; $i < count($data); $i++) {
            if (isset($data[$i]) && $data[$i][$type] > $max[$type]) {
                $max = $data[$i];
            }
        }

        return $max;
    }

    public static function getMinItem(array $data, string $type)
    {
        $min = $data[0] ?? null;
        for ($i = 0; $i < count($data); $i++) {
            if (isset($data[$i]) && $data[$i][$type] < $min[$type]) {
                $min = $data[$i];
            }
        }

        return $min;
    }

    public function getLastCoordinatesByRoute(Route $route, $date): ?TrackerHistory
    {
        return $this->getEntityManager()->createQueryBuilder()
            ->select('th')
            ->from(TrackerHistory::class, 'th')
            ->where('th.device = :device')
            ->andWhere('th.ts >= :dateFrom')
            ->andWhere('th.lat <> 0')
            ->andWhere('th.lng <> 0')
            ->andWhere('th.lat IS NOT NULL')
            ->andWhere('th.lng IS NOT NULL')
            ->setParameter('device', $route->getDevice())
            ->setParameter('dateFrom', $date)
            ->orderBy('th.ts', Criteria::ASC)
            ->getQuery()
            ->setMaxResults(1)
            ->getOneOrNullResult();
    }

    /**
     * @param Route $route
     * @param $date
     * @return TrackerHistory|null
     * @throws \Doctrine\ORM\NonUniqueResultException
     */
    public function getLastTrackerHistoryWithCoordinatesByRoute(Route $route, $date): ?TrackerHistory
    {
        return $this->getEntityManager()->createQueryBuilder()
            ->select('th')
            ->from(TrackerHistory::class, 'th')
            ->where('th.device = :device')
            ->andWhere('th.ts <= :date')
            ->andWhere('th.lat <> 0')
            ->andWhere('th.lng <> 0')
            ->andWhere('th.lat IS NOT NULL')
            ->andWhere('th.lng IS NOT NULL')
            ->setParameter('device', $route->getDevice())
            ->setParameter('date', $date)
            ->orderBy('th.ts', Criteria::DESC)
            ->getQuery()
            ->setMaxResults(1)
            ->getOneOrNullResult();
    }

    public function getLastTHByRouteDateTo(Route $route, $date): ?TrackerHistory
    {
        return $this->getEntityManager()->createQueryBuilder()
            ->select('th')
            ->from(TrackerHistory::class, 'th')
            ->where('th.device = :device')
            ->andWhere('th.ts <= :dateTo')
            ->setParameter('device', $route->getDevice())
            ->setParameter('dateTo', $date)
            ->orderBy('th.ts', Criteria::ASC)
            ->getQuery()
            ->setMaxResults(1)
            ->getOneOrNullResult();
    }

    /**
     * @param Route $route
     * @return array
     */
    public function getSpeedsForRouteStatsQuery(Route $route): array
    {
        return $this->getEntityManager()
            ->createQueryBuilder()
            ->select('AVG(th.speed) as avgSpeed, MAX(th.speed) as maxSpeed')
            ->from(TrackerHistory::class, 'th')
            ->where('th.device = :device')
            ->andWhere('th.speed IS NOT NULL')
            ->andWhere('th.ts >= :dateFrom')
            ->andWhere('th.ts <= :dateTo')
            ->setParameter('device', $route->getDevice())
            ->setParameter('dateFrom', $route->getStartedAt())
            ->setParameter('dateTo', $route->getFinishedAt())
            ->getQuery()
            ->getSingleResult();
    }

    /**
     * @param Speeding $speeding
     * @return array|null
     */
    public function getCoordinatesForSpeedingStats(Speeding $speeding): ?array
    {
        return $this->getEntityManager()
            ->createQueryBuilder()
            ->select('th.speed')
            ->from(TrackerHistory::class, 'th')
            ->where('th.device = :device')
            ->andWhere('th.speed IS NOT NULL')
            ->andWhere('th.ts >= :dateFrom')
            ->andWhere('th.ts < :dateTo')
            ->setParameter('device', $speeding->getDevice())
            ->setParameter('dateFrom', $speeding->getStartedAt())
            ->setParameter('dateTo', $speeding->getFinishedAt())
            ->getQuery()
            ->getResult();
    }

    /**
     * @param int $deviceId
     * @param $dateFrom
     * @param null $dateTo
     * @return \Doctrine\ORM\Query
     */
    public function getTrackerRecordsByDeviceQuery(int $deviceId, $dateFrom, $dateTo = null)
    {
        $qb = $this->getEntityManager()->createQueryBuilder();

        $query = $qb->select('th')
            ->from(TrackerHistory::class, 'th')
            ->where($qb->expr()->eq('IDENTITY(th.device)', $deviceId))
            ->andWhere('th.ts >= :dateFrom')
            ->setParameter('dateFrom', $dateFrom)
            ->orderBy('th.ts', Criteria::ASC);

        if ($dateTo) {
            $query->andWhere('th.ts <= :dateTo')
                ->setParameter('dateTo', $dateTo);
        }

        return $query->getQuery();
    }

    /**
     * @param int $deviceId
     * @param $dateFrom
     * @param null $dateTo
     * @return \Doctrine\ORM\Query
     */
    public function getTrackerRecordsForUpdateEngineOnTimeQuery(int $deviceId, $dateFrom, $dateTo = null)
    {
        $qb = $this->getEntityManager()->createQueryBuilder();

        $query = $qb->select('th.id, th.ts, th.engineOnTime, th.ignition')
            ->from(TrackerHistory::class, 'th')
            ->where($qb->expr()->eq('IDENTITY(th.device)', $deviceId))
            ->andWhere('th.ts >= :dateFrom')
            ->setParameter('dateFrom', $dateFrom)
            ->orderBy('th.ts', Criteria::ASC);

        if ($dateTo) {
            $query->andWhere('th.ts <= :dateTo')
                ->setParameter('dateTo', $dateTo);
        }

        return $query->getQuery();
    }

    /**
     * @param int $deviceId
     * @param \DateTimeInterface $startDate
     * @return mixed
     * @throws \Doctrine\ORM\NonUniqueResultException
     */
    public function getPrevRecordWithEngineOnTimeByDevice(int $deviceId, $startDate)
    {
        $qb = $this->getEntityManager()->createQueryBuilder();

        $query = $qb->select('th')
            ->from(TrackerHistory::class, 'th')
            ->where($qb->expr()->eq('IDENTITY(th.device)', $deviceId))
            ->andWhere('th.ts <= :startDate')
            ->andWhere('th.engineOnTime IS NOT NULL')
            ->setParameter('startDate', $startDate)
            ->orderBy('th.ts', Criteria::DESC);

        return $query->getQuery()->setMaxResults(1)->getOneOrNullResult();
    }

    /**
     * @param int $deviceId
     * @param $dateFrom
     * @param null $dateTo
     * @return array|null
     */
    public function getTrackerRecordsDateAndIgnitionByDevice(int $deviceId, $dateFrom, $dateTo = null)
    {
        $qb = $this->getEntityManager()
            ->createQueryBuilder();

        $query = $qb->select('th.ts, th.ignition')
            ->from(TrackerHistory::class, 'th')
            ->where($qb->expr()->eq('IDENTITY(th.device)', $deviceId))
            ->andWhere('th.ts >= :dateFrom')
            ->setParameter('dateFrom', $dateFrom)
            ->orderBy('th.ts', Criteria::ASC);

        if ($dateTo) {
            $query->andWhere('th.ts <= :dateTo')
                ->setParameter('dateTo', $dateTo);
        }

        return $query
            ->getQuery()
            ->getResult();
    }

    /**
     * @param int $deviceId
     * @param $dateFrom
     * @param null $dateTo
     * @return Query
     * @throws \Exception
     */
    public function getTrackerRecordsByDeviceIdAndDatesQuery(int $deviceId, $dateFrom, $dateTo = null)
    {
        $allowedRecordTS = Carbon::createFromTimestamp(TrackerService::getAllowedRecordTimestamp());
        $qb = $this->getEntityManager()
            ->createQueryBuilder();

        return $qb->select('th')
            ->from(TrackerHistory::class, 'th')
            ->where($qb->expr()->eq('IDENTITY(th.device)', $deviceId))
            ->andWhere('th.ts >= :dateFrom')
            ->andWhere('th.ts <= :dateTo')
            ->andWhere('th.ts >= :allowedRecordTS')
            ->setParameter('dateFrom', $dateFrom)
            ->setParameter('dateTo', $dateTo)
            ->setParameter('allowedRecordTS', $allowedRecordTS)
            ->getQuery();
    }

    /**
     * @param User $driver
     * @param $dateFrom
     * @param $dateTo
     * @return null
     */
    public function getTotalOdometerByDriver(User $driver, $dateFrom, $dateTo)
    {
        $qb = $this->getEntityManager()->getConnection()->createQueryBuilder();

        $result = $qb->select('(MAX(th.odometer) - MIN(th.odometer)) as total_distance')
            ->from($this->getEntityManager()->getClassMetadata(TrackerHistory::class)->getTableName(), 'th')
            ->where('th.driver_id = :driverId')
            ->andWhere('th.ts BETWEEN :dateFrom AND :dateTo')
            ->andWhere('th.odometer IS NOT NULL')
            ->groupBy('th.vehicle_id')
            ->setParameter('driverId', $driver->getId())
            ->setParameter('dateFrom', $dateFrom)
            ->setParameter('dateTo', $dateTo)
            ->execute()
            ->fetchAll();

        return $result ? array_sum(array_column($result, 'total_distance')) : null;
    }

    public function getTotalOdometerByDriverArray(array $drivers, $dateFrom, $dateTo)
    {
        if (empty($drivers)) {
            return [];
        }

        $data = [];

        foreach ($drivers as $driver) {
            $vehicleIds = $this->getEntityManager()->getRepository(DriverHistory::class)
                ->findVehiclesByDriverAndDate($driver, $dateFrom, $dateTo);

            if (!$vehicleIds) {
                $data[$driver] = null;
                continue;
            }

            $result = $this->getEntityManager()->getConnection()->createQueryBuilder()
                ->select('th_vehicle_distance(v.id, :dateFrom, :dateTo) as total_distance, v.id as vehicle_id')
                ->from($this->getEntityManager()->getClassMetadata(Vehicle::class)->getTableName(), 'v')
                ->where('v.id in (' . implode(', ', $vehicleIds) . ')')
                ->setParameter('dateFrom', $dateFrom)
                ->setParameter('dateTo', $dateTo)
                ->execute()
                ->fetchAllAssociative();

            $data[$driver] = array_sum(array_column($result, 'total_distance'));
        }

        return $data;
    }

    /**
     * @param User $user
     * @param $startDate
     * @param $endDate
     * @return mixed
     */
    public function getTotalOdometerByTeam(User $user, $startDate, $endDate)
    {
        $vTable = $this->getEntityManager()->getClassMetadata(Vehicle::class)->getTableName();
        $qb = $this->getEntityManager()->getConnection()->createQueryBuilder();
        $q = $this->getEntityManager()->createQueryBuilder();

        $distanceQuery = $qb->select('SUM(r.distance) as total_distance, r.vehicle_id as vehicle_id')
            ->from($this->getEntityManager()->getClassMetadata(Route::class)->getTableName(), 'r')
            ->innerJoin('r', $vTable, 'v', 'r.vehicle_id = v.id')
            ->andWhere('v.team_id = :team_id')
            ->andWhere('v.status IN (:statuses)')
            ->andWhere('r.type = :type')
            ->andWhere(
                $qb->expr()->and(
                    $qb->expr()->lte('r.started_at', ':dateTo'),
                    $qb->expr()->gte('r.finished_at', ':dateFrom')
                ))
//            ->andWhere(
//                $qb->expr()->or(
//                    $q->expr()->between('r.started_at', ':dateFrom', ':dateTo'),
//                    $q->expr()->between('r.finished_at', ':dateFrom', ':dateTo'),
//                    $qb->expr()->and(
//                        $qb->expr()->lte('r.started_at', ':dateFrom'),
//                        $qb->expr()->gte('r.finished_at', ':dateTo')
//                    )
//                )
//            )
            ->setParameter('team_id', $user->getTeam()->getId())
            ->setParameter('dateFrom', $startDate)
            ->setParameter('dateTo', $endDate)
            ->setParameter('type', Route::TYPE_DRIVING)
            ->setParameter('statuses', Vehicle::LIST_STATUSES, Connection::PARAM_STR_ARRAY)
            ->groupBy('r.vehicle_id');

        if ($user->needToCheckUserGroup()) {
            $userVehicles = $this->getEntityManager()->getRepository(UserGroup::class)
                ->getUserVehiclesIdFromUserGroup($user);
            $distanceQuery->andWhere('r.vehicle_id in (' . implode(', ', $userVehicles) . ')');
        }

        return array_sum(array_column($distanceQuery->execute()->fetchAll(), 'total_distance'));
    }

    /**
     * @param User $user
     * @param $startDate
     * @param $endDate
     * @param string $sort
     * @return mixed
     */
    public function getTopVehiclesByTotalOdometer(User $user, $startDate, $endDate, $sort = 'DESC')
    {
        $vTable = $this->getEntityManager()->getClassMetadata(Vehicle::class)->getTableName();
        $qb = $this->getEntityManager()->getConnection()->createQueryBuilder();
        $q = $this->getEntityManager()->createQueryBuilder();

        $vehiclesQuery = $qb->select(
            'SUM(r.distance) as total_distance,
            SUM(EXTRACT(EPOCH FROM (r.finished_at::timestamp - r.started_at::timestamp))::INTEGER) as total_duration,
             r.vehicle_id as vehicle_id, v.regno as vehicle_regno'
        )
            ->from($this->getEntityManager()->getClassMetadata(Route::class)->getTableName(), 'r')
            ->innerJoin('r', $vTable, 'v', 'r.vehicle_id = v.id')
            ->andWhere('v.team_id = :team_id')
            ->andWhere('v.status IN (:statuses)')
            ->andWhere('r.type = :type')
            ->andWhere(
                $qb->expr()->and(
                    $qb->expr()->lte('r.started_at', ':dateTo'),
                    $qb->expr()->gte('r.finished_at', ':dateFrom')
                ))
//            ->andWhere(
//                $qb->expr()->or(
//                    $q->expr()->between('r.started_at', ':dateFrom', ':dateTo'),
//                    $q->expr()->between('r.finished_at', ':dateFrom', ':dateTo'),
//                    $qb->expr()->and(
//                        $qb->expr()->lte('r.started_at', ':dateFrom'),
//                        $qb->expr()->gte('r.finished_at', ':dateTo')
//                    )
//                )
//            )
            ->setParameter('team_id', $user->getTeam()->getId())
            ->setParameter('dateFrom', $startDate)
            ->setParameter('dateTo', $endDate)
            ->setParameter('type', Route::TYPE_DRIVING)
            ->setParameter('statuses', Vehicle::LIST_STATUSES, Connection::PARAM_STR_ARRAY)
            ->groupBy('r.vehicle_id, vehicle_regno')
            ->orderBy('total_distance', $sort)
            ->setMaxResults(3);

        if ($user->needToCheckUserGroup()) {
            $userVehicles = $this->getEntityManager()->getRepository(UserGroup::class)
                ->getUserVehiclesIdFromUserGroup($user);
            $vehiclesQuery->andWhere('r.vehicle_id in (' . implode(', ', $userVehicles) . ')');
        }

        return $vehiclesQuery->execute()->fetchAll();
    }

    /**
     * @param User $user
     * @param $startDate
     * @param $endDate
     * @param string $sort
     * @return mixed
     */
    public function getTopDriversByTotalOdometer(User $user, $startDate, $endDate, $sort = 'DESC')
    {
        $uTable = $this->getEntityManager()->getClassMetadata(User::class)->getTableName();
        $qb = $this->getEntityManager()->getConnection()->createQueryBuilder();
        $q = $this->getEntityManager()->createQueryBuilder();

        $driversQuery = $qb->select(
            'SUM(r.distance) as total_distance, u.id as driver_id,
            SUM(EXTRACT(EPOCH FROM (r.finished_at::timestamp - r.started_at::timestamp))::INTEGER) as total_duration,
            CONCAT(u.name, \' \', u.surname) as fullName'
        )
            ->from($this->getEntityManager()->getClassMetadata(Route::class)->getTableName(), 'r')
            ->innerJoin('r', $uTable, 'u', 'r.driver_id = u.id')
            ->andWhere('u.team_id = :team_id')
            ->andWhere('u.status IN (:statuses)')
            ->andWhere('r.type = :type')
            ->andWhere(
                $qb->expr()->and(
                    $qb->expr()->lte('r.started_at', ':dateTo'),
                    $qb->expr()->gte('r.finished_at', ':dateFrom')
                ))
//            ->andWhere(
//                $qb->expr()->or(
//                    $q->expr()->between('r.started_at', ':dateFrom', ':dateTo'),
//                    $q->expr()->between('r.finished_at', ':dateFrom', ':dateTo'),
//                    $qb->expr()->and(
//                        $qb->expr()->lte('r.started_at', ':dateFrom'),
//                        $qb->expr()->gte('r.finished_at', ':dateTo')
//                    )
//                )
//            )
            ->setParameter('team_id', $user->getTeam()->getId())
            ->setParameter('dateFrom', $startDate)
            ->setParameter('dateTo', $endDate)
            ->setParameter('type', Route::TYPE_DRIVING)
            ->setParameter('statuses', User::LIST_STATUSES, Connection::PARAM_STR_ARRAY)
            ->groupBy('u.id')
            ->orderBy('total_distance', $sort)
            ->setMaxResults(3);

        if ($user->needToCheckUserGroup()) {
            $userVehicles = $this->getEntityManager()->getRepository(UserGroup::class)
                ->getUserVehiclesIdFromUserGroup($user);
            $driversQuery->andWhere('r.vehicle_id in (' . implode(', ', $userVehicles) . ')');
        }

        return $driversQuery->execute()->fetchAll();
    }

    /**
     * @param User $driver
     * @param $dateFrom
     * @param $dateTo
     * @return null
     */
    public function getTotalDrivingTimeByDriver(User $driver, $dateFrom, $dateTo)
    {
        $drivingBehaviorCalcType = $driver->getTeam()->getSettingsByName(Setting::DRIVING_BEHAVIOR_CALCULATION_TYPE);

        if ($drivingBehaviorCalcType
            && $drivingBehaviorCalcType->getValue() === DrivingBehaviorService::CALCULATION_TYPE_ROUTE) {
            $result = $this->getEntityManager()->getConnection()->createQueryBuilder()
                ->select(
                    'EXTRACT(EPOCH FROM r.started_at)::INTEGER as started_at,
                EXTRACT(EPOCH FROM r.finished_at)::INTEGER as finished_at'
                )
//                ->select('SUM(r.total_movement_duration) as duration')
                ->from($this->getEntityManager()->getClassMetadata(Route::class)->getTableName(), 'r')
                ->where('r.driver_id = :driverId')
                ->andWhere('r.started_at <= :dateTo')
                ->andWhere('r.finished_at >= :dateFrom')
                ->andWhere('r.type = :routeType')
                ->setParameter('driverId', $driver->getId())
                ->setParameter('dateFrom', $dateFrom)
                ->setParameter('dateTo', $dateTo)
                ->setParameter('routeType', Route::TYPE_DRIVING)
//                ->groupBy('r.driver_id')
                ->execute()
                ->fetchAll();

//            return $result['duration'] ?? null;
//
            return $result ? RouteHelper::calcDrivingTimeByRoutes($result, $dateFrom, $dateTo) : null;
        } else {
            $result = $this->getEntityManager()->getConnection()->createQueryBuilder()
                ->select(
                    'EXTRACT(EPOCH FROM th.ts)::INTEGER as ts, th.ignition::TEXT, th.movement::TEXT'
                )
                ->from($this->getEntityManager()->getClassMetadata(TrackerHistory::class)->getTableName(), 'th')
                ->where('th.driver_id = :driverId')
                ->andWhere('th.ts BETWEEN :dateFrom AND :dateTo')
                ->setParameter('driverId', $driver->getId())
                ->setParameter('dateFrom', $dateFrom)
                ->setParameter('dateTo', $dateTo)
                ->orderBy('th.ts')
                ->execute()
                ->fetchAll();

            return $result ? GeoHelper::calcDrivingTimeAccordingToDeviceStatus($result) : null;
        }
    }

    /**
     * @param array $ids
     * @return null|array
     */
    public function getTrackerHistoriesTsAndIgnitionByIds(array $ids): ?array
    {
        return $this->getEntityManager()
            ->createQueryBuilder()
            ->select('th.ts, th.ignition')
            ->from(TrackerHistory::class, 'th')
            ->where('th.id IN (:ids)')
            ->orderBy('th.ts')
            ->setParameter('ids', array_values($ids))
            ->getQuery()
            ->getResult();
    }

    /**
     * @param array $ids
     * @return null|TrackerHistory
     * @throws \Doctrine\ORM\NonUniqueResultException
     */
    public function getTrackerHistoryWithMaxOdometerByIds(array $ids): ?TrackerHistory
    {
        return $this->getEntityManager()
            ->createQueryBuilder()
            ->select('th')
            ->from(TrackerHistory::class, 'th')
            ->where('th.id IN (:ids)')
            ->andWhere('th.odometer IS NOT NULL')
            ->orderBy('th.odometer', Criteria::DESC)
            ->setParameter('ids', array_values($ids))
            ->getQuery()
            ->setMaxResults(1)
            ->getOneOrNullResult();
    }

    /**
     * @param Device $device
     * @param TrackerHistory $th
     * @return TrackerHistory|null
     * @throws \Doctrine\ORM\NonUniqueResultException
     */
    public function getLastTrackerHistoryWithExternalVoltage(Device $device, TrackerHistory $th): ?TrackerHistory
    {
        if (!$device->getVehicle()) {
            return null;
        }

        return $this->getEntityManager()
            ->createQueryBuilder()
            ->select('th')
            ->from(TrackerHistory::class, 'th')
            ->andWhere('th.device = :device')
            ->andWhere('th.ts < :thTs')
            ->andWhere('th.id != :thId')
            ->andWhere('th.externalVoltage IS NOT NULL')
            ->setParameter('device', $device)
            ->setParameter('thId', $th->getId())
            ->setParameter('thTs', $th->getTs())
            ->orderBy('th.ts', Criteria::DESC)
            ->getQuery()
            ->setMaxResults(1)
            ->getOneOrNullResult();
    }

    public function getLastTrackerHistoryWithBattery(Device $device, TrackerHistory $th): ?TrackerHistory
    {
        if (!$device->getVehicle()) {
            return null;
        }

        return $this->getEntityManager()
            ->createQueryBuilder()
            ->select('th')
            ->from(TrackerHistory::class, 'th')
            ->andWhere('th.device = :device')
            ->andWhere('th.ts < :thTs')
            ->andWhere('th.id != :thId')
            ->andWhere('th.batteryVoltagePercentage IS NOT NULL')
            ->setParameter('device', $device)
            ->setParameter('thId', $th->getId())
            ->setParameter('thTs', $th->getTs())
            ->orderBy('th.ts', Criteria::DESC)
            ->getQuery()
            ->setMaxResults(1)
            ->getOneOrNullResult();
    }

    /**
     * @param Device $device
     * @param TrackerHistory $th
     * @return TrackerHistory|null
     * @throws \Doctrine\ORM\NonUniqueResultException
     */
    public function getLastTrackerHistoryWithSpeed(Device $device, TrackerHistory $th): ?TrackerHistory
    {
        if (!$device->getVehicle()) {
            return null;
        }

        return $this->getEntityManager()
            ->createQueryBuilder()
            ->select('th')
            ->from(TrackerHistory::class, 'th')
            ->andWhere('th.device = :device')
            ->andWhere('th.ts < :thTs')
            ->andWhere('th.id != :thId')
            ->andWhere('th.speed IS NOT NULL')
            ->setParameter('device', $device)
            ->setParameter('thId', $th->getId())
            ->setParameter('thTs', $th->getTs())
            ->orderBy('th.ts', Criteria::DESC)
            ->getQuery()
            ->setMaxResults(1)
            ->getOneOrNullResult();
    }

    /**
     * @param array $vehicleIds
     * @param \DateTime|null $dateFrom
     * @param \DateTime|null $dateTo
     * @return Query
     */
    public function getTrackerHistoryByVehicleQuery(
        array      $vehicleIds,
        ?\DateTime $dateFrom = null,
        ?\DateTime $dateTo = null
    ) {
        $q = $this->getEntityManager()
            ->createQueryBuilder()
            ->select('IDENTITY(th.vehicle) as vehicle_id')
            ->addSelect('IDENTITY(th.device) as device_id')
            ->addSelect('th.id')
            ->addSelect('th.ts as timestamp')
            ->addSelect('th.lng as longitude')
            ->addSelect('th.lat as latitude')
            ->addSelect('IDENTITY(th.driver) as driver_id')
            ->addSelect('th.odometer as odometer_km')
            ->addSelect('th.speed as speed_km_h')
            ->addSelect('th.alt as altitude_m')
            ->addSelect('th.ignition as ignition_on')
            ->addSelect('th.angle as heading')
            ->from(TrackerHistory::class, 'th')
            ->andWhere('IDENTITY(th.vehicle) IN (:vehicleIds)')
            ->setParameter('vehicleIds', $vehicleIds)
            ->orderBy('th.id', Criteria::DESC);

        if ($dateFrom) {
            $q->andWhere('th.ts >= :dateFrom')
                ->setParameter('dateFrom', $dateFrom);
        }

        if ($dateTo) {
            $q->andWhere('th.ts <= :dateTo')
                ->setParameter('dateTo', $dateTo);
        }

        return $q->getQuery();
    }

    /**
     * @param array $ids
     * @return null|TrackerHistory[]
     * @throws \Doctrine\ORM\NonUniqueResultException
     */
    public function getTrackerHistoriesByIds(array $ids)
    {
        return $this->getEntityManager()
            ->createQueryBuilder()
            ->select('th')
            ->from(TrackerHistory::class, 'th')
            ->where('th.id IN (:ids)')
            ->orderBy('th.ts', Criteria::ASC)
            ->setParameter('ids', $ids)
            ->getQuery()
            ->getResult();
    }

    public function getTrackerHistoryByVehicleAndDate(Vehicle $vehicle, \DateTime $from, \DateTime $to)
    {
        return $this->getEntityManager()
            ->createQueryBuilder()
            ->select('th')
            ->from(TrackerHistory::class, 'th')
            ->andWhere('th.vehicle = :vehicle')
            ->andWhere('th.ts > :from')
            ->andWhere('th.ts < :to')
            ->andWhere('th.lat IS NOT NULL')
            ->andWhere('th.lng IS NOT NULL')
            ->setParameter('vehicle', $vehicle)
            ->setParameter('from', $from)
            ->setParameter('to', $to)
            ->orderBy('th.ts', Criteria::DESC)
            ->getQuery()
            ->getResult();
    }

    /**
     * @param int $deviceId
     * @param string|null $startedAt
     * @param string|null $finishedAt
     * @return mixed
     */
    public function updateTrackerHistoryIsCalculatedRouteFlag(int $deviceId, ?string $startedAt, ?string $finishedAt)
    {
        $query = $this->getEntityManager()
            ->createQueryBuilder()
            ->update(TrackerHistory::class, 'th')
            ->set('th.isCalculated', 'false')
            ->where('th.device = :deviceId')
            ->setParameter('deviceId', $deviceId);

        if ($startedAt) {
            $query->andWhere('th.ts >= :startedAt')
                ->setParameter('startedAt', $startedAt);
        }

        if ($finishedAt) {
            $query->andWhere('th.ts <= :finishedAt')
                ->setParameter('finishedAt', $finishedAt);
        }

        $query->getQuery()->execute();
    }

    /**
     * @param int $deviceId
     * @param string|null $startedAt
     * @param string|null $finishedAt
     */
    public function updateTrackerHistoryIsCalculatedIdlingFlag(
        int     $deviceId,
        ?string $startedAt,
        ?string $finishedAt
    ) {
        $query = $this->getEntityManager()
            ->createQueryBuilder()
            ->update(TrackerHistory::class, 'th')
            ->set('th.isCalculatedIdling', 'false')
            ->where('th.device = :deviceId')
            ->setParameter('deviceId', $deviceId);

        if ($startedAt) {
            $query->andWhere('th.ts >= :startedAt')
                ->setParameter('startedAt', $startedAt);
        }

        if ($finishedAt) {
            $query->andWhere('th.ts <= :finishedAt')
                ->setParameter('finishedAt', $finishedAt);
        }

        $query->getQuery()->execute();
    }

    /**
     * @param int $deviceId
     * @param string|null $startedAt
     * @param string|null $finishedAt
     */
    public function updateTrackerHistoryIsCalculatedSpeedingFlag(
        int     $deviceId,
        ?string $startedAt,
        ?string $finishedAt
    ) {
        $query = $this->getEntityManager()
            ->createQueryBuilder()
            ->update(TrackerHistory::class, 'th')
            ->set('th.isCalculatedSpeeding', 'false')
            ->where('th.device = :deviceId')
            ->setParameter('deviceId', $deviceId);

        if ($startedAt) {
            $query->andWhere('th.ts >= :startedAt')
                ->setParameter('startedAt', $startedAt);
        }

        if ($finishedAt) {
            $query->andWhere('th.ts <= :finishedAt')
                ->setParameter('finishedAt', $finishedAt);
        }

        $query->getQuery()->execute();
    }

    public function updateEngineOnTime(int $id, ?float $engineOnTime)
    {
        if (is_null($engineOnTime)) {
            return;
        }

        $thTable = $this->getEntityManager()->getClassMetadata(TrackerHistory::class)->getTableName();

        return $this->getEntityManager()->getConnection()
            ->executeQuery("UPDATE $thTable SET engine_on_time = ? WHERE id = ?", [$engineOnTime, $id]);
    }

    public function getPartialRoute(
        Vehicle $vehicle,
        ?string $startedAt = null,
        ?string $finishedAt = null
    ): ?array {
        $qb = $this->getEntityManager()->createQueryBuilder();
        $query = $qb->addSelect('MAX(th.ts) AS max_ts, MIN(th.ts) AS min_ts')
            ->addSelect('MAX(th.odometer) AS max_odometer, MIN(th.odometer) AS min_odometer')
            ->addSelect('MAX(th.speed) AS max_speed')
            ->addSelect('MAX(th.odometer) - MIN(th.odometer) AS distance')
            ->from(TrackerHistory::class, 'th')
            ->andWhere($qb->expr()->eq('IDENTITY(th.vehicle)', ':vehicleId'))
            ->andWhere('th.ts >= :startedAt')
            ->setParameter('startedAt', $startedAt)
            ->andWhere('th.ts <= :finishedAt')
            ->setParameter('finishedAt', $finishedAt)
            ->setParameter('vehicleId', $vehicle->getId());

        $result = $query->getQuery()->getResult();

        return $result ? $result[0] : [];
    }

    public function updateTHsDriverByRoute(Route $route)
    {
        $query = $this->getEntityManager()
            ->createQueryBuilder()
            ->update(TrackerHistory::class, 'th')
            ->set('th.driver', ':driver')
            ->andWhere('th.device = :device')
            ->andWhere('th.ts >= :startThTs')
            ->andWhere('th.ts < :finishThTs')
            ->setParameter('driver', $route->getDriver())
            ->setParameter('device', $route->getDevice())
            ->setParameter('startThTs', $route->getPointStart()->getTs())
            ->setParameter('finishThTs', $route->getPointFinish()->getTs());

        $query->getQuery()->execute();
    }

    /**
     * @param Device $device
     * @param Vehicle|null $vehicle
     * @param int $odometer
     * @param \DateTimeInterface|string|null $dateFrom
     * @param \DateTimeInterface|string|null $dateTo
     * @return mixed
     */
    public function updateTrackerHistoriesOdometer(
        Device   $device,
        ?Vehicle $vehicle,
        int      $odometer,
                 $dateFrom = null,
                 $dateTo = null
    ) {
        $query = $this->getEntityManager()
            ->createQueryBuilder()
            ->update(TrackerHistory::class, 'th')
            ->set('th.odometer', $odometer)
            ->where('th.device = :device')
            ->setParameter('device', $device);

        if ($vehicle) {
            $query->andWhere('th.vehicle = :vehicle')
                ->setParameter('vehicle', $vehicle);
        }
        if ($dateFrom) {
            $query->andWhere('th.ts >= :dateFrom')
                ->setParameter('dateFrom', $dateFrom);
        }
        if ($dateTo) {
            $query->andWhere('th.ts <= :dateTo')
                ->setParameter('dateTo', $dateTo);
        }

        return $query->getQuery()->execute();
    }

    /**
     * @param int $deviceId
     * @param string|null $tsFrom
     * @param string|null $tsTo
     * @param string|null $createdAtFrom
     * @param string|null $createdAtTo
     * @return Query
     */
    public function getRecordsForUpdatingWrongOdometerQuery(
        int     $deviceId,
        ?string $tsFrom,
        ?string $tsTo,
        ?string $createdAtFrom,
        ?string $createdAtTo
    ): Query {
        $query = $this->getEntityManager()
            ->createQueryBuilder()
            ->select('th.id, tp.payload, th.ts')
            ->from(TrackerHistory::class, 'th')
            ->leftJoin(TrackerPayload::class, 'tp', Query\Expr\Join::WITH, 'th.trackerPayload = tp')
            ->where('IDENTITY(th.device) = :deviceId')
            ->setParameter('deviceId', $deviceId)
            ->andWhere('tp IS NOT NULL')
            ->andWhere('th.odometer IS NULL');

        if ($tsFrom) {
            $query->andWhere('th.ts >= :tsFrom')
                ->setParameter('tsFrom', $tsFrom);
        }
        if ($tsTo) {
            $query->andWhere('th.ts <= :tsTo')
                ->setParameter('tsTo', $tsTo);
        }
        if ($createdAtFrom) {
            $query->andWhere('th.createdAt >= :createdAtFrom')
                ->setParameter('createdAtFrom', $createdAtFrom);
        }
        if ($createdAtTo) {
            $query->andWhere('th.createdAt <= :createdAtTo')
                ->setParameter('createdAtTo', $createdAtTo);
        }

        return $query->getQuery();
    }

    /**
     * @param int $thId
     * @param int $odometer
     * @return mixed
     */
    public function updateTrackerHistoryOdometerById(
        int $thId,
        int $odometer
    ) {
        $query = $this->getEntityManager()
            ->createQueryBuilder()
            ->update(TrackerHistory::class, 'th')
            ->set('th.odometer', $odometer)
            ->where('th.id = :thId')
            ->setParameter('thId', $thId);

        return $query->getQuery()->execute();
    }

    /**
     * @param Device $device
     * @param \DateTime|string|null $ts
     * @return array|null
     * @throws \Doctrine\ORM\NonUniqueResultException
     */
    public function getFirstTrackerRecordForOdometerUpdateByDevice(Device $device, $ts): ?array
    {
        $query = $this->getEntityManager()
            ->createQueryBuilder()
            ->select('th.id, th.odometer, th.ts')
            ->from(TrackerHistory::class, 'th')
            ->where('th.device = :device')
            ->andWhere('th.odometer IS NOT NULL')
            ->setParameter('device', $device)
            ->orderBy('th.ts', Criteria::ASC);

        if ($ts) {
            $query->andWhere('th.ts < :ts')
                ->setParameter('ts', $ts);
        }

        return $query
            ->getQuery()
            ->setMaxResults(1)
            ->getOneOrNullResult();
    }

    /**
     * @param Device $device
     * @param \DateTime|string|null $ts
     * @return \DateTime|null
     * @throws \Doctrine\ORM\NonUniqueResultException
     */
    public function getPrevTrackerHistoryWithOdometer(Device $device, $ts): ?array
    {
        return $this->getEntityManager()
            ->createQueryBuilder()
            ->select('th.id, th.odometer, th.ts')
            ->from(TrackerHistory::class, 'th')
            ->where('th.device = :device')
            ->andWhere('th.ts < :date')
            ->andWhere('th.odometer IS NOT NULL')
            ->setParameter('device', $device)
            ->setParameter('date', $ts)
            ->orderBy('th.ts', Criteria::DESC)
            ->getQuery()
            ->setMaxResults(1)
            ->getOneOrNullResult();
    }

    /**
     * @param Device $device
     * @return array|null
     * @throws \Doctrine\ORM\NonUniqueResultException
     */
    public function getFirstRecordWithMinOdometerByDevice(Device $device): ?array
    {
        return $this->getEntityManager()
            ->createQueryBuilder()
            ->select('MIN(th.odometer) AS min_odo, th.id, th.odometer, th.ts')
            ->from(TrackerHistory::class, 'th')
            ->where('th.device = :device')
            ->andWhere('th.odometer < :maxOdometer')
            ->andWhere('th.odometer > 0')
            ->setParameter('device', $device)
            ->setParameter('maxOdometer', Data::ODOMETER_LIMIT_MAX)
            ->groupBy('th.id')
            ->orderBy('th.ts', Criteria::ASC)
            ->getQuery()
            ->setMaxResults(1)
            ->getOneOrNullResult();
    }

    /**
     * @param Device $device
     * @param int $odometer
     * @param \DateTime|string|null $startTs
     * @param \DateTime|string|null $endTs
     * @return mixed
     */
    public function updateTrackerHistoryOdometerByRange(
        Device $device,
        int    $odometer,
               $startTs,
               $endTs
    ) {
        $query = $this->getEntityManager()
            ->createQueryBuilder()
            ->update(TrackerHistory::class, 'th')
            ->set('th.odometer', $odometer)
            ->where('th.device = :device')
            ->andWhere('th.ts >= :startTs')
            ->andWhere('th.ts <= :endTs')
            ->andWhere('th.odometer > :maxOdometer')
            ->setParameter('startTs', $startTs)
            ->setParameter('endTs', $endTs)
            ->setParameter('maxOdometer', Data::ODOMETER_LIMIT_MAX)
            ->setParameter('device', $device);

        return $query->getQuery()->execute();
    }

    public function getThIterable(
        Vehicle          $vehicle,
        \DateTime|string $dateFrom,
        \DateTime|string $dateTo,
        string           $sort = 'th.ts',
        string           $fields = 'th.id, th.odometer, th.lat, th.lng',
        string           $order = 'DESC'
    ): Query {
        $query = $this->getEntityManager()
            ->createQueryBuilder()
            ->select($fields)
            ->from(TrackerHistory::class, 'th')
            ->andWhere('th.vehicle = :vehicle')
            ->setParameter('vehicle', $vehicle)
            ->andWhere('th.lat is not null')
            ->andWhere('th.lng is not null');

        if ($sort) {
            $query->orderBy($sort, $order);
        }

        if ($dateFrom) {
            $query->andWhere('th.ts >= :tsFrom')->setParameter('tsFrom', $dateFrom);
        }
        if ($dateTo) {
            $query->andWhere('th.ts <= :tsTo')->setParameter('tsTo', $dateTo);
        }

        return $query->getQuery();
    }

    /**
     * @param int $deviceId
     * @param string|null $startedAt
     * @param string|null $finishedAt
     * @return QueryBuilder
     */
    public function getQueryToUpdateIgnitionBySpeedFixFlag(
        int     $deviceId,
        ?string $startedAt,
        ?string $finishedAt
    ): QueryBuilder {
        $query = $this->getEntityManager()
            ->createQueryBuilder()
            ->update(TrackerHistory::class, 'th')
            ->where('th.device = :deviceId')
            ->setParameter('deviceId', $deviceId);

        if ($startedAt) {
            $query->andWhere('th.ts >= :startedAt')
                ->setParameter('startedAt', $startedAt);
        }
        if ($finishedAt) {
            $query->andWhere('th.ts <= :finishedAt')
                ->setParameter('finishedAt', $finishedAt);
        }

        return $query;
    }

    public function getThDataByRoute(
        Route  $route,
        string $fields = 'th.movement, th.ignition, th.ts, th.odometer, th.speed'
    ): ?array {
        $query = $this->getEntityManager()
            ->createQueryBuilder()
            ->select($fields)
            ->from(TrackerHistory::class, 'th')
            ->where('th.device = :device')
            ->andWhere('th.ts >= :dateFrom')
            ->andWhere('th.ts <= :dateTo')
            ->andWhere('th.lat IS NOT NULL')
            ->andWhere('th.lng IS NOT NULL')
            ->andWhere('th.alt IS NOT NULL')
            ->andWhere('th.angle IS NOT NULL')
            ->setParameter('device', $route->getDevice())
            ->setParameter('dateFrom', $route->getStartedAt())
            ->setParameter('dateTo', $route->getFinishedAt())
            ->orderBy('th.ts', Criteria::DESC)
            ->getQuery();

        return $query->getResult();
    }

    public function getDataWithMinValidOdometerForRoute(Route $route, int $odoDiff): ?array
    {
        return $this->getEntityManager()
            ->createQueryBuilder()
            ->select('MIN(th.odometer) as min_odo, th.ts')
            ->from(TrackerHistory::class, 'th')
            ->where('th.device = :device')
            ->andWhere('th.odometer > 0')
            ->andWhere('th.ts >= :dateFrom')
            ->andWhere('th.ts <= :dateTo')
            ->andWhere('ABS(th.odometer - :finishOdometer) < :odoDiff')
            ->groupBy('th.ts')
            ->setParameter('device', $route->getDevice())
            ->setParameter('dateFrom', $route->getStartedAt())
            ->setParameter('dateTo', $route->getFinishedAt())
            ->setParameter('finishOdometer', $route->getFinishOdometer())
            ->setParameter('odoDiff', $odoDiff)
            ->getQuery()
            ->setMaxResults(1)
            ->getOneOrNullResult();
    }

    public function getTrackerRecordsByDeviceInRangeQuery(
        int $deviceId,
        $dateFrom,
        $dateTo = null,
        bool $withCoordinates = false,
        bool $withSpeed = false,
    ): Query {
        $qb = $this->getEntityManager()->createQueryBuilder();
        $query = $qb->select('th')
            ->from(TrackerHistory::class, 'th')
            ->where($qb->expr()->eq('IDENTITY(th.device)', $deviceId))
            ->orderBy('th.ts', Order::Ascending->value);

        if ($dateFrom) {
            $query->andWhere('th.ts >= :dateFrom')
                ->setParameter('dateFrom', $dateFrom);
        }
        if ($dateTo) {
            $query->andWhere('th.ts <= :dateTo')
                ->setParameter('dateTo', $dateTo);
        }
        if ($withCoordinates) {
            $query->andWhere('th.lat <> 0')
                ->andWhere('th.lng <> 0')
                ->andWhere('th.lat IS NOT NULL')
                ->andWhere('th.lng IS NOT NULL');
        }
        if ($withSpeed) {
            $query->andWhere('th.speed IS NOT NULL');
        }

        return $query->getQuery();
    }
}
